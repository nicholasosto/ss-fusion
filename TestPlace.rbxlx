<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">TS</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
-- SS-Fusion Component Library
-- A custom component library built on @rbxts/fusion
for _k, _v in TS.import(script, script, "examples", "ExampleUsage") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "examples", "TabGroupExample") or {} do
	exports[_k] = _v
end
-- Export types
for _k, _v in TS.import(script, script, "types", "common") or {} do
	exports[_k] = _v
end
-- Export utilities
for _k, _v in TS.import(script, script, "utils", "theme") or {} do
	exports[_k] = _v
end
-- Export atoms
for _k, _v in TS.import(script, script, "atoms") or {} do
	exports[_k] = _v
end
-- Export molecules
for _k, _v in TS.import(script, script, "molecules") or {} do
	exports[_k] = _v
end
-- Export organisms
for _k, _v in TS.import(script, script, "organisms") or {} do
	exports[_k] = _v
end
-- Export additional types
for _k, _v in TS.import(script, script, "types", "tabs") or {} do
	exports[_k] = _v
end
-- Export layout primitives
for _k, _v in TS.import(script, script, "layout", "Stack") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "layout", "Grid") or {} do
	exports[_k] = _v
end
return exports
]]></string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">atoms</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
--[[
	*
	 * @fileoverview SS-Fusion Atoms - Foundational UI Components
	 * @description Exports all atomic components for the SS-Fusion design system.
	 * 
	 * Atoms are the smallest, most basic UI components that serve as building blocks
	 * for more complex molecules, organisms, and templates. This library includes:
	 * 
	 * - **Avatar**: User profile images, player thumbnails, and fallback displays
	 * - **Button**: Unified text and icon button with multiple variants
	 * - **Label**: Typography component with consistent theming
	 * - **TextBox**: Input component with validation and focus states
	 * - **ProgressBar**: Progress visualization for various metrics
	 * - **SlicedImage**: Generic 9-slice image component for panels
	 * 
	 * All components are built with:
	 * ✅ Fusion reactive state integration
	 * ✅ Comprehensive TypeScript interfaces
	 * ✅ Consistent theming system
	 * ✅ Full JSDoc documentation
	 * ✅ Performance optimizations
	 * 
	 * @example Basic Usage
	 * ```typescript
	 * import { Avatar, Button, Label, TextBox } from "ss-fusion/atoms";
	 * 
	 * // Create a user profile header
	 * const userProfile = [
	 *   Avatar({ UserId: 123456, Size: UDim2.fromOffset(64, 64) }),
	 *   Label({ text: "Welcome back!", variant: "heading" }),
	 *   Button({ text: "View Profile", variant: "primary" })
	 * ];
	 * ```
	 * 
	 * @see {@link ./README.md} For detailed usage documentation
	 * @see {@link ./CHANGELOG.md} For version history and migration guides
	 * @see {@link ./atoms.d.ts} For complete API reference
	 
]]
for _k, _v in TS.import(script, script, "Button") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Label") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TextBox") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "ProgressBar") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "SlicedImage") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TabButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Badge") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "Avatar") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "IconButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "CloseButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "MessageBox") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">Avatar</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file Avatar.ts
	 * @module Avatar
	 * @layer Client/UI/Atoms
	 * @description User avatar/thumbnail component that fetches a player's image via GetUserThumbnailAsync.
	 *
	 * - Defaults to the local player's UserId when none is provided
	 * - Supports shape (circle/rounded/square), size variants, and optional border
	 * - Provides a placeholder image while loading or on failure
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local New = _fusion.New
local Value = _fusion.Value
local Observer = _fusion.Observer
local defaultColorScheme = TS.import(script, script.Parent.Parent, "utils", "theme").defaultColorScheme
local ImageConstants = TS.import(script, script.Parent.Parent, "types", "image-assets").ImageConstants
local Players = game:GetService("Players")
local function sizePresetToPixels(size)
	repeat
		local _fallthrough = false
		if size == "small" then
			return 48
		end
		if size == "large" then
			return 180
		end
		if size == "medium" then
		end
		return 100
	until true
end
local function sizePresetToThumbnail(size)
	repeat
		local _fallthrough = false
		if size == "small" then
			return Enum.ThumbnailSize.Size48x48
		end
		if size == "large" then
			return Enum.ThumbnailSize.Size180x180
		end
		if size == "medium" then
		end
		return Enum.ThumbnailSize.Size100x100
	until true
end
--[[
	*
	 * Create an Avatar component that displays a user's Roblox thumbnail.
	 
]]
local function Avatar(props)
	-- Defaults
	local shape = props.shape or "circle"
	local sizePreset = props.size or "medium"
	local _condition = props.showBorder
	if _condition == nil then
		_condition = false
	end
	local showBorder = _condition
	local borderColor = props.borderColor or defaultColorScheme.Surface
	local backgroundColor = props.backgroundColor or Color3.fromRGB(0, 0, 0)
	local _condition_1 = props.placeholderImage
	if _condition_1 == nil then
		_condition_1 = ImageConstants.DefaultUnassigned
	end
	local placeholder = _condition_1
	local thumbType = props.thumbnailType or Enum.ThumbnailType.HeadShot
	local px = sizePresetToPixels(sizePreset)
	local thumbSize = sizePresetToThumbnail(sizePreset)
	-- Unify userId into a state for observation
	local _userId = props.userId
	local _result
	if type(_userId) == "number" then
		_result = Value(props.userId)
	else
		local _condition_2 = (props.userId)
		if _condition_2 == nil then
			local _result_1 = Players.LocalPlayer
			if _result_1 ~= nil then
				_result_1 = _result_1.UserId
			end
			local _condition_3 = _result_1
			if _condition_3 == nil then
				_condition_3 = 0
			end
			_condition_2 = Value(_condition_3)
		end
		_result = _condition_2
	end
	local userIdState = _result
	-- Image state
	local imageState = Value(placeholder)
	-- Fetch function
	local fetchThumbnail = function(uid)
		task.spawn(function()
			local _condition_2 = uid
			if _condition_2 ~= 0 and _condition_2 == _condition_2 and _condition_2 then
				_condition_2 = uid > 0
			end
			if _condition_2 ~= 0 and _condition_2 == _condition_2 and _condition_2 then
				local url, isReady = Players:GetUserThumbnailAsync(uid, thumbType, thumbSize)
				imageState:set(if isReady and url ~= "" then url else placeholder)
			else
				imageState:set(placeholder)
			end
		end)
	end
	-- Initial fetch and re-fetch on userId change
	fetchThumbnail(userIdState:get())
	Observer(userIdState):onChange(function()
		return fetchThumbnail(userIdState:get())
	end)
	-- Visual nodes
	local image = New("ImageLabel")({
		Name = "AvatarImage",
		BackgroundColor3 = backgroundColor,
		BackgroundTransparency = 0,
		Size = UDim2.new(1, 0, 1, 0),
		Image = imageState,
		ScaleType = Enum.ScaleType.Fit,
		ClipsDescendants = true,
		ZIndex = 2,
	})
	-- Corner radius for shape
	local corner = New("UICorner")({
		CornerRadius = if shape == "circle" then UDim.new(1, 0) elseif shape == "rounded" then UDim.new(0, 8) else UDim.new(0, 0),
	})
	corner.Parent = image
	-- Optional border
	if showBorder then
		local stroke = New("UIStroke")({
			Color = borderColor,
			Thickness = 2,
			Transparency = 0,
			ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		})
		stroke.Parent = image
	end
	-- Container (allows external sizing via props.Size or preset fallback)
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_2 = props.Name
	if _condition_2 == nil then
		_condition_2 = "Avatar"
	end
	_object[_left] = _condition_2
	_object.Size = props.Size or UDim2.new(0, px, 0, px)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.BackgroundTransparency = 1
	_object.BorderSizePixel = 0
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object[Children] = { image }
	_object.Visible = props.Visible
	_object.ClipsDescendants = props.ClipsDescendants
	local container = _fn(_object)
	-- Keep square aspect if externally resized
	local aspect = New("UIAspectRatioConstraint")({
		AspectRatio = 1,
	})
	aspect.Parent = container
	return container
end
return {
	Avatar = Avatar,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">Badge</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * Badge.ts
	 * Lightweight status/count label with theme variants, sizes, and optional icon or dot mode.
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
local fontSizes = _theme.fontSizes
local function variantToBackground(variant)
	repeat
		local _fallthrough = false
		if variant == "primary" then
			return defaultColorScheme.Primary
		end
		if variant == "secondary" then
			return defaultColorScheme.Secondary
		end
		if variant == "accent" then
			return defaultColorScheme.Accent
		end
		if variant == "success" then
			return defaultColorScheme.Success
		end
		if variant == "warning" then
			return defaultColorScheme.Warning
		end
		if variant == "danger" then
			return defaultColorScheme.Error
		end
		if variant == "neutral" then
		end
		return defaultColorScheme.Surface
	until true
end
local function variantToText(variant)
	repeat
		if variant == "secondary" then
			return defaultColorScheme.OnSecondary
		end
		if variant == "neutral" then
			return defaultColorScheme.OnSurface
		end
		return defaultColorScheme.OnPrimary
	until true
end
local function sizeConfig(size)
	repeat
		local _fallthrough = false
		if size == "small" then
			return {
				height = 18,
				padX = spacing.xs,
				iconScale = 0.6,
				font = fontSizes.xs,
				dot = 8,
			}
		end
		if size == "large" then
			return {
				height = 28,
				padX = spacing.md,
				iconScale = 0.7,
				font = fontSizes.lg,
				dot = 12,
			}
		end
		if size == "medium" then
		end
		return {
			height = 22,
			padX = spacing.sm,
			iconScale = 0.65,
			font = fontSizes.sm,
			dot = 10,
		}
	until true
end
local function shapeCorner(shape, heightPx)
	if shape == "pill" then
		return heightPx / 2
	end
	if shape == "rounded" then
		return 8
	end
	return 0
end
local function Badge(props)
	local variant = props.variant or "primary"
	local size = props.size or "medium"
	local shape = props.shape or "pill"
	local _condition = props.maxValue
	if _condition == nil then
		_condition = 99
	end
	local maxValue = _condition
	local cfg = sizeConfig(size)
	local bg = variantToBackground(variant)
	local fg = props.textColor or variantToText(variant)
	-- Dot mode: render a small circle only
	if props.dot then
		local _fn = New("Frame")
		local _object = {}
		local _left = "Name"
		local _condition_1 = props.Name
		if _condition_1 == nil then
			_condition_1 = "BadgeDot"
		end
		_object[_left] = _condition_1
		_object.Size = props.Size or UDim2.new(0, cfg.dot, 0, cfg.dot)
		_object.Position = props.Position
		_object.AnchorPoint = props.AnchorPoint
		_object.BackgroundColor3 = bg
		_object.BackgroundTransparency = 0
		_object.BorderSizePixel = 0
		_object.ZIndex = props.ZIndex
		_object.LayoutOrder = props.LayoutOrder
		_object.Visible = props.Visible
		_object[Children] = { New("UICorner")({
			CornerRadius = UDim.new(0, cfg.dot / 2),
		}) }
		return _fn(_object)
	end
	-- Compute display text from text/value
	local textState = props.text
	local valueState = props.value
	local display = Computed(function()
		local label = ""
		if type(textState) == "string" then
			label = textState
		elseif textState then
			label = textState:get()
		end
		local countStr = ""
		if type(valueState) == "number" then
			local v = valueState
			countStr = if v > maxValue then `{maxValue}+` else tostring(v)
		elseif valueState then
			local v = valueState:get()
			countStr = if v > maxValue then `{maxValue}+` else tostring(v)
		end
		if label ~= "" and countStr ~= "" then
			return `{label} {countStr}`
		end
		return if label ~= "" then label else countStr
	end)
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_1 = props.Name
	if _condition_1 == nil then
		_condition_1 = "Badge"
	end
	_object[_left] = _condition_1
	_object.Size = props.Size or UDim2.new(0, 0, 0, cfg.height)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.AutomaticSize = Enum.AutomaticSize.X
	_object.BackgroundColor3 = bg
	_object.BorderSizePixel = 0
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object.Visible = props.Visible
	_object[Children] = { New("UIListLayout")({
		FillDirection = Enum.FillDirection.Horizontal,
		VerticalAlignment = Enum.VerticalAlignment.Center,
		HorizontalAlignment = Enum.HorizontalAlignment.Center,
		Padding = UDim.new(0, 4),
	}), New("UIPadding")({
		PaddingLeft = UDim.new(0, cfg.padX),
		PaddingRight = UDim.new(0, cfg.padX),
	}) }
	local container = _fn(_object)
	-- Optional icon
	local _value = props.icon
	if _value ~= "" and _value then
		local icon = New("ImageLabel")({
			Name = "Icon",
			BackgroundTransparency = 1,
			Image = props.icon,
			ImageColor3 = fg,
			Size = UDim2.new(0, math.floor(cfg.height * cfg.iconScale), 0, math.floor(cfg.height * cfg.iconScale)),
		})
		icon.Parent = container
	end
	-- Label text
	local label = New("TextLabel")({
		Name = "Text",
		BackgroundTransparency = 1,
		Text = display,
		TextColor3 = fg,
		TextSize = cfg.font,
		Font = Enum.Font.GothamMedium,
		AutomaticSize = Enum.AutomaticSize.X,
		Size = UDim2.new(0, 0, 1, 0),
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
	})
	label.Parent = container
	-- Shape
	local corner = New("UICorner")({
		CornerRadius = UDim.new(0, shapeCorner(shape, cfg.height)),
	})
	corner.Parent = container
	return container
end
return {
	Badge = Badge,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">Button</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file Button.ts
	 * @module Button
	 * @layer Client/UI/Atoms
	 * @description Unified button component that supports both text and icon modes with multiple variants and states.
	 * 
	 * This component consolidates the functionality of text buttons and icon buttons into a single,
	 * flexible component that can handle various use cases while maintaining consistent theming.
	 *
	 * @example
	 * // Text button
	 * const saveButton = Button({
	 *   text: "Save",
	 *   variant: "primary",
	 *   onClick: () => saveData()
	 * });
	 * 
	 * @example
	 * // Icon button
	 * const settingsButton = Button({
	 *   icon: "rbxassetid://123456789",
	 *   variant: "icon",
	 *   size: "medium",
	 *   onClick: () => openSettings()
	 * });
	 * 
	 * @example
	 * // Custom styled button with background image
	 * const styledButton = Button({
	 *   text: "Epic Button",
	 *   backgroundImage: "rbxassetid://987654321",
	 *   variant: "accent",
	 *   onClick: () => doEpicAction()
	 * });
	 *
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
--[[
	*
	 * Props interface for the unified Button component.
	 * Supports both text and icon buttons with comprehensive theming options.
	 
]]
--[[
	*
	 * Creates a unified button component that can display text, icons, or custom content.
	 * 
	 * This component automatically detects whether to render as a text or icon button based on props.
	 * It provides consistent theming, hover states, and accessibility features.
	 * 
	 * @param props - Configuration object for the button
	 * @returns A Frame containing the button with proper interaction handling
	 * 
	 * @example
	 * // Simple text button
	 * const button = Button({
	 *   text: "Click me",
	 *   onClick: () => print("Clicked!")
	 * });
	 * 
	 * @example
	 * // Icon button with custom color
	 * const iconBtn = Button({
	 *   icon: "rbxassetid://123",
	 *   variant: "icon",
	 *   iconColor: Color3.fromRGB(255, 100, 100),
	 *   onClick: handleIconClick
	 * });
	 
]]
local function Button(props)
	-- State management
	local isHovered = Value(false)
	local isPressed = Value(false)
	-- Default values
	local variant = props.variant or "primary"
	local size = props.size or "medium"
	local _condition = props.text
	if _condition == nil then
		_condition = ""
	end
	local text = _condition
	local _condition_1 = props.iconSize
	if _condition_1 == nil then
		_condition_1 = 0.8
	end
	local iconSize = _condition_1
	local iconColor = props.iconColor or Color3.fromRGB(255, 255, 255)
	-- Determine if this is an icon button
	local _value = props.icon
	local _condition_2 = not not (_value ~= "" and _value)
	if not _condition_2 then
		_condition_2 = variant == "icon"
	end
	local isIconButton = _condition_2
	-- Compute disabled state
	local isDisabled = Computed(function()
		local _disabled = props.disabled
		if type(_disabled) == "boolean" then
			return props.disabled
		elseif props.disabled then
			return props.disabled:get()
		end
		return false
	end)
	-- Get colors based on variant and state
	local getBackgroundColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(100, 100, 100)
		end
		local baseColors = {
			primary = defaultColorScheme.Primary,
			secondary = defaultColorScheme.Secondary,
			accent = defaultColorScheme.Accent,
			danger = defaultColorScheme.Error,
			ghost = Color3.fromRGB(0, 0, 0),
			icon = defaultColorScheme.Surface,
		}
		return baseColors[variant] or baseColors.primary
	end
	local getTextColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(150, 150, 150)
		end
		if variant == "ghost" or variant == "icon" then
			return defaultColorScheme.OnSurface
		end
		return if variant == "secondary" then defaultColorScheme.OnSecondary else defaultColorScheme.OnPrimary
	end
	local getIconColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(150, 150, 150)
		end
		if variant == "icon" then
			return if isHovered:get() then iconColor else Color3.fromRGB(200, 200, 200)
		end
		return iconColor
	end
	-- Get size values
	local getSizeValues = function()
		repeat
			if size == "small" then
				return {
					height = if isIconButton then 32 else 32,
					width = if isIconButton then 32 else 100,
					paddingX = spacing.sm,
					fontSize = 14,
				}
			end
			if size == "medium" then
				return {
					height = if isIconButton then 40 else 40,
					width = if isIconButton then 40 else 120,
					paddingX = spacing.md,
					fontSize = 16,
				}
			end
			if size == "large" then
				return {
					height = if isIconButton then 48 else 48,
					width = if isIconButton then 48 else 150,
					paddingX = spacing.lg,
					fontSize = 18,
				}
			end
			return {
				height = if isIconButton then 40 else 40,
				width = if isIconButton then 40 else 120,
				paddingX = spacing.md,
				fontSize = 16,
			}
		until true
	end
	local sizeValues = getSizeValues()
	-- Computed styles
	local backgroundColor = Computed(function()
		return getBackgroundColor()
	end)
	local backgroundTransparency = Computed(function()
		if variant == "ghost" then
			return if isHovered:get() then 0.9 else 1
		end
		if variant == "icon" then
			return if isHovered:get() then 0.8 else 1
		end
		if isPressed:get() then
			return 0.1
		end
		if isHovered:get() then
			return 0.2
		end
		return 0
	end)
	local textColor = Computed(function()
		return getTextColor()
	end)
	local computedIconColor = Computed(function()
		return getIconColor()
	end)
	-- Compute text content
	local displayText = Computed(function()
		if type(text) == "string" then
			return text
		else
			return text:get()
		end
	end)
	-- Create the button content
	local buttonContent = {}
	if props.children then
		for _, child in props.children do
			table.insert(buttonContent, child)
		end
	else
		local _value_1 = isIconButton and props.icon
		if _value_1 ~= "" and _value_1 then
			-- Icon button content
			local iconLabel = New("ImageLabel")({
				Name = "Icon",
				Size = UDim2.fromScale(iconSize, iconSize),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
				Image = props.icon,
				ImageColor3 = computedIconColor,
				BackgroundTransparency = 1,
				ZIndex = 2,
			})
			table.insert(buttonContent, iconLabel)
			-- Add aspect ratio constraint for icon buttons
			local aspectRatio = New("UIAspectRatioConstraint")({
				AspectRatio = 1,
			})
			table.insert(buttonContent, aspectRatio)
		elseif text ~= "" and text then
			-- Text button content
			local textLabel = New("TextLabel")({
				Name = "Text",
				Size = UDim2.new(1, -sizeValues.paddingX * 2, 1, 0),
				Position = UDim2.new(0, sizeValues.paddingX, 0, 0),
				BackgroundTransparency = 1,
				Text = displayText,
				TextColor3 = textColor,
				TextSize = sizeValues.fontSize,
				Font = Enum.Font.GothamMedium,
				TextXAlignment = Enum.TextXAlignment.Center,
				TextYAlignment = Enum.TextYAlignment.Center,
				ZIndex = 2,
			})
			table.insert(buttonContent, textLabel)
		end
	end
	-- Create the main button frame
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_3 = props.Name
	if _condition_3 == nil then
		_condition_3 = "Button"
	end
	_object[_left] = _condition_3
	_object.Size = props.Size or UDim2.new(0, sizeValues.width, 0, sizeValues.height)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.BackgroundColor3 = backgroundColor
	_object.BackgroundTransparency = backgroundTransparency
	_object.BorderSizePixel = if (variant == "ghost" or variant == "icon") then 1 else 0
	_object.BorderColor3 = if (variant == "ghost" or variant == "icon") then defaultColorScheme.Secondary else Color3.fromRGB(0, 0, 0)
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object[Children] = buttonContent
	_object.Visible = props.Visible
	_object.ClipsDescendants = props.ClipsDescendants
	local buttonFrame = _fn(_object)
	-- Add background image if provided
	local _value_1 = props.backgroundImage
	if _value_1 ~= "" and _value_1 then
		local backgroundImageLabel = New("ImageLabel")({
			Name = "BackgroundImage",
			Size = UDim2.new(1, 0, 1, 0),
			Image = props.backgroundImage,
			BackgroundTransparency = 1,
			ZIndex = 1,
		})
		backgroundImageLabel.Parent = buttonFrame
	end
	-- Create invisible button for interaction
	local interactionButton = New("TextButton")({
		Name = "InteractionButton",
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		Text = "",
		Active = Computed(function()
			return not isDisabled:get()
		end),
		ZIndex = 10,
		[OnEvent("MouseEnter")] = function()
			if not isDisabled:get() then
				isHovered:set(true)
				local _result = props.onMouseEnter
				if _result ~= nil then
					_result()
				end
			end
		end,
		[OnEvent("MouseLeave")] = function()
			isHovered:set(false)
			isPressed:set(false)
			local _result = props.onMouseLeave
			if _result ~= nil then
				_result()
			end
		end,
		[OnEvent("MouseButton1Down")] = function()
			if not isDisabled:get() then
				isPressed:set(true)
			end
		end,
		[OnEvent("MouseButton1Up")] = function()
			isPressed:set(false)
		end,
		[OnEvent("Activated")] = function()
			if not isDisabled:get() then
				local _result = props.onClick
				if _result ~= nil then
					_result()
				end
			end
		end,
	})
	interactionButton.Parent = buttonFrame
	return buttonFrame
end
return {
	Button = Button,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="6">
          <Properties>
            <string name="Name">CloseButton</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file CloseButton.ts
	 * @module CloseButton
	 * @layer Client/UI/Atoms
	 * @description Minimalist close button component with hover effects and consistent theming.
	 *
	 * A simple, reusable close button that integrates with the ss-fusion theme system.
	 * Perfect for dialogs, modals, and any interface that needs a close control.
	 *
	 * @example
	 * // Basic close button
	 * const closeBtn = CloseButton({
	 *   onClick: () => closeDialog()
	 * });
	 *
	 * @example
	 * // Styled close button
	 * const styledCloseBtn = CloseButton({
	 *   size: "large",
	 *   variant: "error",
	 *   onClick: () => closeWithWarning()
	 * });
	 *
	 * @author SS-Fusion Development Team
	 * @since 2.1.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local Computed = _fusion.Computed
local defaultColorScheme = TS.import(script, script.Parent.Parent, "utils", "theme").defaultColorScheme
--[[
	*
	 * Size configuration mapping
	 
]]
local sizeConfig = {
	small = UDim2.new(0, 24, 0, 24),
	medium = UDim2.new(0, 32, 0, 32),
	large = UDim2.new(0, 40, 0, 40),
}
--[[
	*
	 * Default close icon (Unicode X)
	 
]]
local DEFAULT_CLOSE_TEXT = "✕"
--[[
	*
	 * Get theme colors for variant
	 
]]
local function getVariantColors(variant)
	repeat
		if variant == "error" then
			return {
				normal = defaultColorScheme.Error,
				hover = defaultColorScheme.Error:Lerp(Color3.fromRGB(255, 255, 255), 0.2),
			}
		end
		if variant == "warning" then
			return {
				normal = defaultColorScheme.Warning,
				hover = defaultColorScheme.Warning:Lerp(Color3.fromRGB(255, 255, 255), 0.2),
			}
		end
		if variant == "primary" then
			return {
				normal = defaultColorScheme.Primary,
				hover = defaultColorScheme.Primary:Lerp(Color3.fromRGB(255, 255, 255), 0.2),
			}
		end
		return {
			normal = defaultColorScheme.OnSurface,
			hover = defaultColorScheme.OnSurface:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
		}
	until true
end
--[[
	*
	 * CloseButton component
	 
]]
local function CloseButton(props)
	local isHovered = Value(false)
	local isPressed = Value(false)
	-- Configuration
	local size = props.size or "medium"
	local variant = props.variant or "secondary"
	local themeColors = getVariantColors(variant)
	-- If a custom icon is provided, use ImageButton, otherwise use TextButton
	local _value = props.closeIcon
	if _value ~= "" and _value then
		return New("ImageButton")({
			Name = "CloseButton",
			Size = props.Size or sizeConfig[size],
			Position = props.Position or UDim2.new(1, 0, 0, 0),
			AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0.5),
			LayoutOrder = props.LayoutOrder,
			ZIndex = props.ZIndex,
			Visible = props.Visible,
			BackgroundTransparency = Computed(function()
				if isPressed:get() then
					return 0.7
				elseif isHovered:get() then
					return 0.8
				else
					return 1
				end
			end),
			BackgroundColor3 = themeColors.normal,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Image = props.closeIcon,
			ImageColor3 = Computed(function()
				if isPressed:get() then
					return themeColors.normal:Lerp(Color3.fromRGB(0, 0, 0), 0.3)
				elseif isHovered:get() then
					return themeColors.hover
				else
					return themeColors.normal
				end
			end),
			ImageTransparency = 0,
			[OnEvent("MouseEnter")] = function()
				isHovered:set(true)
				local _result = props.OnMouseEnter
				if _result ~= nil then
					_result()
				end
			end,
			[OnEvent("MouseLeave")] = function()
				isHovered:set(false)
				isPressed:set(false)
				local _result = props.OnMouseLeave
				if _result ~= nil then
					_result()
				end
			end,
			[OnEvent("MouseButton1Down")] = function()
				isPressed:set(true)
			end,
			[OnEvent("MouseButton1Up")] = function()
				isPressed:set(false)
			end,
			[OnEvent("Activated")] = function()
				local _result = props.onClick
				if _result ~= nil then
					_result()
				end
				local _result_1 = props.OnActivated
				if _result_1 ~= nil then
					_result_1()
				end
			end,
		})
	else
		-- Text-based close button
		return New("TextButton")({
			Name = "CloseButton",
			Size = props.Size or sizeConfig[size],
			Position = props.Position,
			AnchorPoint = props.AnchorPoint or Vector2.new(1, 0),
			LayoutOrder = props.LayoutOrder,
			ZIndex = props.ZIndex,
			Visible = props.Visible,
			BackgroundTransparency = Computed(function()
				if isPressed:get() then
					return 0.7
				elseif isHovered:get() then
					return 0.8
				else
					return 1
				end
			end),
			BackgroundColor3 = themeColors.normal,
			BorderSizePixel = 0,
			AutoButtonColor = false,
			Text = DEFAULT_CLOSE_TEXT,
			TextColor3 = Computed(function()
				if isPressed:get() then
					return themeColors.normal:Lerp(Color3.fromRGB(0, 0, 0), 0.3)
				elseif isHovered:get() then
					return themeColors.hover
				else
					return themeColors.normal
				end
			end),
			TextScaled = true,
			Font = Enum.Font.SourceSansBold,
			[OnEvent("MouseEnter")] = function()
				isHovered:set(true)
				local _result = props.OnMouseEnter
				if _result ~= nil then
					_result()
				end
			end,
			[OnEvent("MouseLeave")] = function()
				isHovered:set(false)
				isPressed:set(false)
				local _result = props.OnMouseLeave
				if _result ~= nil then
					_result()
				end
			end,
			[OnEvent("MouseButton1Down")] = function()
				isPressed:set(true)
			end,
			[OnEvent("MouseButton1Up")] = function()
				isPressed:set(false)
			end,
			[OnEvent("Activated")] = function()
				local _result = props.onClick
				if _result ~= nil then
					_result()
				end
				local _result_1 = props.OnActivated
				if _result_1 ~= nil then
					_result_1()
				end
			end,
		})
	end
end
return {
	CloseButton = CloseButton,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">IconButton</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file IconButton.ts
	 * @module IconButton
	 * @layer Client/UI/Atoms
	 * @description Enhanced icon button component with selection states, hover effects, and configurable styling.
	 *
	 * This button supports both simple icon display and advanced interaction states including
	 * selection tracking, hover effects, and customizable background images. Fully integrated
	 * with the ss-fusion theme system.
	 *
	 * @example
	 * // Simple icon button
	 * const button = IconButton({
	 *   icon: "rbxassetid://123456789",
	 *   onClick: () => print("Clicked!")
	 * });
	 *
	 * @example
	 * // Styled button with theme variant
	 * const styledButton = IconButton({
	 *   icon: "rbxassetid://123456789", 
	 *   variant: "primary",
	 *   size: "large",
	 *   onClick: handleClick
	 * });
	 *
	 * @author SS-Fusion Development Team
	 * @since 2.1.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Value = _fusion.Value
local Children = _fusion.Children
local New = _fusion.New
local Computed = _fusion.Computed
local OnEvent = _fusion.OnEvent
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local borderRadiusValues = _theme.borderRadiusValues
--[[
	*
	 * Size configuration mapping
	 
]]
local sizeConfig = {
	small = UDim2.fromOffset(32, 32),
	medium = UDim2.fromOffset(48, 48),
	large = UDim2.fromOffset(64, 64),
}
--[[
	*
	 * Get theme colors for variant
	 
]]
local function getVariantColors(variant)
	repeat
		if variant == "primary" then
			return {
				background = defaultColorScheme.Primary,
				text = defaultColorScheme.OnPrimary,
			}
		end
		if variant == "secondary" then
			return {
				background = defaultColorScheme.Secondary,
				text = defaultColorScheme.OnSecondary,
			}
		end
		if variant == "accent" then
			return {
				background = defaultColorScheme.Accent,
				text = defaultColorScheme.OnPrimary,
			}
		end
		if variant == "error" then
			return {
				background = defaultColorScheme.Error,
				text = defaultColorScheme.OnPrimary,
			}
		end
		if variant == "success" then
			return {
				background = defaultColorScheme.Success,
				text = defaultColorScheme.OnPrimary,
			}
		end
		if variant == "warning" then
			return {
				background = defaultColorScheme.Warning,
				text = defaultColorScheme.OnPrimary,
			}
		end
		return {
			background = defaultColorScheme.Surface,
			text = defaultColorScheme.OnSurface,
		}
	until true
end
local function IconButton(props)
	local _condition = props.initialSelected
	if _condition == nil then
		_condition = false
	end
	local isSelected = Value(_condition)
	local isHovered = Value(false)
	local isPressed = Value(false)
	-- Configuration
	local size = props.size or "medium"
	local variant = props.variant or "secondary"
	local _condition_1 = props.toggleable
	if _condition_1 == nil then
		_condition_1 = false
	end
	local toggleable = _condition_1
	local themeColors = getVariantColors(variant)
	-- Default background image (Roblox placeholder)
	local defaultBackground = "rbxasset://textures/ui/GuiImagePlaceholder.png"
	-- Icon Image
	local IconImage = New("ImageLabel")({
		Name = "IconImage",
		Size = UDim2.fromScale(0.7, 0.7),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5),
		Image = props.icon,
		ImageColor3 = Computed(function()
			if isSelected:get() then
				return themeColors.text
			elseif isPressed:get() then
				return themeColors.text:Lerp(Color3.fromRGB(0, 0, 0), 0.2)
			elseif isHovered:get() then
				return themeColors.text
			else
				return themeColors.text:Lerp(Color3.fromRGB(128, 128, 128), 0.3)
			end
		end),
		BackgroundTransparency = 1,
		ZIndex = 2,
	})
	-- Selection highlight
	local SelectionHighlight = New("Frame")({
		Name = "SelectionHighlight",
		Size = UDim2.fromScale(1, 1),
		BackgroundColor3 = themeColors.background,
		BackgroundTransparency = Computed(function()
			if isSelected:get() then
				return 0.1
			elseif isPressed:get() then
				return 0.3
			elseif isHovered:get() then
				return 0.5
			else
				return 1
			end
		end),
		BorderSizePixel = 0,
		ZIndex = 1,
		[Children] = {
			Corner = New("UICorner")({
				CornerRadius = UDim.new(0, borderRadiusValues.small),
			}),
		},
	})
	local BackgroundTransparency = Computed(function()
		if isPressed:get() then
			return 0.3
		elseif isHovered:get() then
			return 0.5
		else
			return 1
		end
	end)
	local backgroundColor = Computed(function()
		if isSelected:get() then
			return themeColors.background
		elseif isPressed:get() then
			return themeColors.background:Lerp(Color3.fromRGB(0, 0, 0), 0.2)
		elseif isHovered:get() then
			return themeColors.background
		else
			return themeColors.background:Lerp(Color3.fromRGB(128, 128, 128), 0.3)
		end
	end)
	-- Main Button Component
	local _fn = New("ImageButton")
	local _object = {
		Name = "IconButton",
		Size = props.Size or sizeConfig[size],
		Position = props.Position,
		AnchorPoint = props.AnchorPoint,
		LayoutOrder = props.LayoutOrder,
		ZIndex = props.ZIndex,
		Visible = props.Visible,
	}
	local _left = "Image"
	local _condition_2 = props.backgroundImage
	if _condition_2 == nil then
		_condition_2 = defaultBackground
	end
	_object[_left] = _condition_2
	local _left_1 = "ImageTransparency"
	local _value = props.backgroundImage
	_object[_left_1] = if _value ~= "" and _value then 0 else 1
	_object.BackgroundTransparency = BackgroundTransparency
	_object.BackgroundColor3 = backgroundColor
	_object.AutoButtonColor = false
	_object[Children] = {
		SelectionHighlight = SelectionHighlight,
		IconImage = IconImage,
		AspectRatioConstraint = New("UIAspectRatioConstraint")({
			AspectRatio = 1,
		}),
	}
	_object[OnEvent("MouseEnter")] = function()
		isHovered:set(true)
		local _result = props.OnMouseEnter
		if _result ~= nil then
			_result()
		end
	end
	_object[OnEvent("MouseLeave")] = function()
		isHovered:set(false)
		isPressed:set(false)
		local _result = props.OnMouseLeave
		if _result ~= nil then
			_result()
		end
	end
	_object[OnEvent("MouseButton1Down")] = function()
		isPressed:set(true)
	end
	_object[OnEvent("MouseButton1Up")] = function()
		isPressed:set(false)
	end
	_object[OnEvent("Activated")] = function()
		if toggleable then
			local newSelected = not isSelected:get()
			isSelected:set(newSelected)
			local _result = props.onSelectionChanged
			if _result ~= nil then
				_result(newSelected)
			end
		end
		local _result = props.onClick
		if _result ~= nil then
			_result()
		end
		local _result_1 = props.OnActivated
		if _result_1 ~= nil then
			_result_1()
		end
	end
	local buttonComponent = _fn(_object)
	return buttonComponent
end
return {
	IconButton = IconButton,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">Label</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file Label.ts
	 * @module Label
	 * @layer Client/UI/Atoms
	 * @description Reusable text label component with consistent theming and typography.
	 * 
	 * This component provides a standardized way to display text with proper theming,
	 * typography variants, and accessibility features. It handles both static and
	 * reactive text content.
	 *
	 * @example
	 * // Simple heading
	 * const title = Label({
	 *   text: "Welcome to SS-Fusion",
	 *   variant: "heading"
	 * });
	 * 
	 * @example
	 * // Reactive body text
	 * const status = Label({
	 *   text: statusText, // Value<string>
	 *   variant: "body",
	 *   textColor: Color3.fromRGB(100, 255, 100)
	 * });
	 * 
	 * @example
	 * // Caption with text stroke
	 * const caption = Label({
	 *   text: "Level 25 Warrior",
	 *   variant: "caption",
	 *   textStroke: true,
	 *   textStrokeColor: Color3.fromRGB(0, 0, 0)
	 * });
	 *
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Computed = _fusion.Computed
local New = _fusion.New
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local fontSizes = _theme.fontSizes
--[[
	*
	 * Props interface for the Label component.
	 * Provides comprehensive text styling and typography options.
	 
]]
--[[
	*
	 * Creates a text label with consistent theming and typography.
	 * 
	 * This component handles both static and reactive text content, automatically
	 * applying appropriate styling based on the selected variant. It integrates
	 * with the theme system for consistent colors and spacing.
	 * 
	 * @param props - Configuration object for the label
	 * @returns A TextLabel instance with proper styling applied
	 * 
	 * @example
	 * // Basic usage
	 * const welcomeText = Label({
	 *   text: "Welcome, Player!",
	 *   variant: "heading"
	 * });
	 * 
	 * @example
	 * // Reactive text with custom styling
	 * const scoreLabel = Label({
	 *   text: scoreState,
	 *   variant: "body",
	 *   textColor: Color3.fromRGB(255, 215, 0),
	 *   textStroke: true
	 * });
	 
]]
local function Label(props)
	-- Default values based on variant
	local variant = props.variant or "body"
	local textColor = props.textColor or defaultColorScheme.OnSurface
	local _condition = props.textScaled
	if _condition == nil then
		_condition = false
	end
	local textScaled = _condition
	local font = props.font or Enum.Font.Gotham
	local textXAlignment = props.textXAlignment or Enum.TextXAlignment.Center
	local textYAlignment = props.textYAlignment or Enum.TextYAlignment.Center
	local _condition_1 = props.textWrapped
	if _condition_1 == nil then
		_condition_1 = false
	end
	local textWrapped = _condition_1
	local _condition_2 = props.textStroke
	if _condition_2 == nil then
		_condition_2 = false
	end
	local textStroke = _condition_2
	local textStrokeColor = props.textStrokeColor or Color3.fromRGB(0, 0, 0)
	local _condition_3 = props.textStrokeTransparency
	if _condition_3 == nil then
		_condition_3 = 0.5
	end
	local textStrokeTransparency = _condition_3
	-- Get text size based on variant
	local getTextSize = function(variant)
		repeat
			if variant == "heading" then
				return fontSizes.xxl
			end
			if variant == "body" then
				return fontSizes.md
			end
			if variant == "caption" then
				return fontSizes.sm
			end
			if variant == "small" then
				return fontSizes.xs
			end
			return fontSizes.md
		until true
	end
	-- Compute text content
	local displayText = Computed(function()
		local _text = props.text
		if type(_text) == "string" then
			return props.text
		else
			return props.text:get()
		end
	end)
	local _fn = New("TextLabel")
	local _object = {}
	local _left = "Name"
	local _condition_4 = props.Name
	if _condition_4 == nil then
		_condition_4 = "Label"
	end
	_object[_left] = _condition_4
	_object.Size = props.Size or UDim2.new(1, 0, 0, getTextSize(variant) + 8)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	local _left_1 = "BackgroundTransparency"
	local _condition_5 = props.BackgroundTransparency
	if _condition_5 == nil then
		_condition_5 = 1
	end
	_object[_left_1] = _condition_5
	_object.BackgroundColor3 = props.BackgroundColor3
	local _left_2 = "BorderSizePixel"
	local _condition_6 = props.BorderSizePixel
	if _condition_6 == nil then
		_condition_6 = 0
	end
	_object[_left_2] = _condition_6
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object.Text = displayText
	_object.TextColor3 = textColor
	_object.TextSize = if textScaled then 14 else getTextSize(variant)
	_object.TextScaled = textScaled
	_object.Font = font
	_object.TextXAlignment = textXAlignment
	_object.TextYAlignment = textYAlignment
	_object.TextWrapped = textWrapped
	_object.TextStrokeTransparency = if textStroke then textStrokeTransparency else 1
	_object.TextStrokeColor3 = textStrokeColor
	_object.Visible = props.Visible
	_object.ClipsDescendants = props.ClipsDescendants
	return _fn(_object)
end
return {
	Label = Label,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">MessageBox</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file MessageBox.ts
	 * @module MessageBox
	 * @layer Client/UI/Atoms
	 * @description Notification/message display component with automatic styling based on message type.
	 *
	 * A reactive message box that displays temporary messages to users with appropriate
	 * color coding and theming. Integrates with the ss-fusion theme system.
	 *
	 * @example
	 * // Basic message box
	 * const messageBox = MessageBox({
	 *   message: "Operation completed successfully!",
	 *   messageType: "success",
	 *   visible: true
	 * });
	 *
	 * @example
	 * // Reactive message box with state
	 * const messageState = Value("Loading...");
	 * const messageBox = MessageBox({
	 *   message: messageState,
	 *   messageType: "info",
	 *   autoHide: true,
	 *   duration: 3
	 * });
	 *
	 * @author SS-Fusion Development Team
	 * @since 2.1.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local Value = _fusion.Value
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
local borderRadiusValues = _theme.borderRadiusValues
local fontSizes = _theme.fontSizes
--[[
	*
	 * Get theme colors for message type
	 
]]
local function getMessageTypeColors(messageType)
	repeat
		local _fallthrough = false
		if messageType == "error" then
			return {
				background = defaultColorScheme.Error,
				text = defaultColorScheme.OnPrimary,
				border = defaultColorScheme.Error:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		if messageType == "warning" then
			return {
				background = defaultColorScheme.Warning,
				text = defaultColorScheme.OnBackground,
				border = defaultColorScheme.Warning:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		if messageType == "success" then
			return {
				background = defaultColorScheme.Success,
				text = defaultColorScheme.OnPrimary,
				border = defaultColorScheme.Success:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		if messageType == "info" then
		end
		return {
			background = defaultColorScheme.Primary,
			text = defaultColorScheme.OnPrimary,
			border = defaultColorScheme.Primary:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
		}
	until true
end
--[[
	*
	 * MessageBox component
	 
]]
local function MessageBox(props)
	local messageType = props.messageType or "info"
	local themeColors = getMessageTypeColors(messageType)
	local isVisible = Value(true)
	-- Get message text (handle both string and Value<string>)
	local messageText = Computed(function()
		local _message = props.message
		if type(_message) == "string" then
			return props.message
		else
			return props.message:get()
		end
	end)
	-- Auto-hide functionality
	if props.autoHide then
		local _condition = props.duration
		if _condition == nil then
			_condition = 3
		end
		local duration = _condition
		task.delay(duration, function()
			isVisible:set(false)
			local _result = props.onDismiss
			if _result ~= nil then
				_result()
			end
		end)
	end
	-- Message icon based on type
	local getMessageIcon = function(messageType)
		repeat
			local _fallthrough = false
			if messageType == "error" then
				return "⚠"
			end
			if messageType == "warning" then
				return "⚠"
			end
			if messageType == "success" then
				return "✓"
			end
			if messageType == "info" then
			end
			return "ℹ"
		until true
	end
	-- Icon element
	local IconLabel = New("TextLabel")({
		Name = "MessageIcon",
		Size = UDim2.new(0, 24, 1, 0),
		Position = UDim2.new(0, spacing.sm, 0, 0),
		BackgroundTransparency = 1,
		Text = getMessageIcon(messageType),
		TextColor3 = props.textColor or themeColors.text,
		TextScaled = true,
		Font = Enum.Font.SourceSansBold,
		TextXAlignment = Enum.TextXAlignment.Center,
		TextYAlignment = Enum.TextYAlignment.Center,
	})
	-- Message text label
	local TextLabel = New("TextLabel")({
		Name = "MessageText",
		Size = UDim2.new(1, -64, 1, 0),
		Position = UDim2.new(0, 40, 0, 0),
		BackgroundTransparency = 1,
		Text = messageText,
		TextColor3 = props.textColor or themeColors.text,
		TextSize = fontSizes.md,
		TextWrapped = true,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Center,
		Font = Enum.Font.SourceSans,
	})
	-- Main message container
	local _fn = New("Frame")
	local _object = {
		Name = "MessageBox",
		Size = props.Size or UDim2.new(0.6, 0, 0, 60),
		Position = props.Position or UDim2.new(0.5, 0, 0.1, 0),
		AnchorPoint = props.AnchorPoint or Vector2.new(0.5, 0),
		LayoutOrder = props.LayoutOrder,
	}
	local _left = "ZIndex"
	local _condition = props.ZIndex
	if _condition == nil then
		_condition = 1000
	end
	_object[_left] = _condition
	_object.Visible = Computed(function()
		if props.Visible ~= nil then
			local _visible = props.Visible
			if type(_visible) == "boolean" then
				return props.Visible and isVisible:get()
			else
				return props.Visible:get() and isVisible:get()
			end
		end
		return isVisible:get()
	end)
	_object.BackgroundColor3 = props.backgroundColor or themeColors.background
	_object.BorderSizePixel = 1
	_object.BorderColor3 = themeColors.border
	_object[Children] = {
		Corner = New("UICorner")({
			CornerRadius = UDim.new(0, borderRadiusValues.medium),
		}),
		Padding = New("UIPadding")({
			PaddingTop = UDim.new(0, spacing.sm),
			PaddingBottom = UDim.new(0, spacing.sm),
			PaddingLeft = UDim.new(0, spacing.sm),
			PaddingRight = UDim.new(0, spacing.sm),
		}),
		Icon = IconLabel,
		Text = TextLabel,
		DropShadow = New("ImageLabel")({
			Name = "DropShadow",
			Size = UDim2.new(1, 6, 1, 6),
			Position = UDim2.new(0, 3, 0, 3),
			AnchorPoint = Vector2.new(0, 0),
			BackgroundTransparency = 1,
			Image = "rbxasset://textures/ui/Controls/DropShadow.png",
			ImageColor3 = Color3.fromRGB(0, 0, 0),
			ImageTransparency = 0.5,
			ScaleType = Enum.ScaleType.Slice,
			SliceCenter = Rect.new(12, 12, 244, 244),
			ZIndex = -1,
		}),
	}
	local messageContainer = _fn(_object)
	return messageContainer
end
return {
	MessageBox = MessageBox,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">ProgressBar</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file ProgressBar.ts
	 * @module ProgressBar
	 * @layer Client/UI/Atoms
	 * @description Reusable progress bar component for health, mana, cooldowns, experience, and other progress indicators.
	 *
	 * This component provides a flexible progress visualization that can work with both
	 * percentage values (0-1) and absolute values (current/max). It supports horizontal
	 * and vertical orientations with optional text labels.
	 *
	 * @example
	 * // Health bar with current/max values
	 * const healthBar = ProgressBar({
	 *   progress: currentHealth,
	 *   maxValue: maxHealth,
	 *   fillColor: Color3.fromRGB(255, 100, 100),
	 *   showLabel: true
	 * });
	 * 
	 * @example
	 * // Experience bar with percentage
	 * const xpBar = ProgressBar({
	 *   progress: expPercentage, // 0.0 to 1.0
	 *   fillColor: Color3.fromRGB(100, 255, 100),
	 *   direction: "horizontal",
	 *   showLabel: true,
	 *   labelText: customExpText
	 * });
	 * 
	 * @example
	 * // Vertical mana bar
	 * const manaBar = ProgressBar({
	 *   progress: currentMana,
	 *   maxValue: maxMana,
	 *   fillColor: Color3.fromRGB(100, 100, 255),
	 *   direction: "vertical",
	 *   minSize: 8
	 * });
	 *
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local defaultColorScheme = TS.import(script, script.Parent.Parent, "utils", "theme").defaultColorScheme
--[[
	*
	 * Props interface for the ProgressBar component.
	 * Supports both percentage-based and absolute value progress tracking.
	 
]]
--[[
	*
	 * Creates a progress bar component for visualizing completion or resource levels.
	 * 
	 * This component automatically handles the math for both percentage-based progress
	 * (0-1 range) and absolute value progress (current/max). It provides smooth
	 * visual feedback with optional text labels and supports both orientations.
	 * 
	 * @param props - Configuration object for the progress bar
	 * @returns A Frame containing the progress bar with fill and optional label
	 * 
	 * @example
	 * // Simple percentage progress
	 * const loadingBar = ProgressBar({
	 *   progress: loadingProgress, // StateObject with 0-1 values
	 *   fillColor: Color3.fromRGB(100, 200, 255),
	 *   showLabel: true
	 * });
	 * 
	 * @example
	 * // Health bar with current/max
	 * const healthBar = ProgressBar({
	 *   progress: playerHealth,    // StateObject with current health
	 *   maxValue: playerMaxHealth, // StateObject with max health
	 *   fillColor: Color3.fromRGB(255, 100, 100),
	 *   showLabel: true,
	 *   labelColor: Color3.fromRGB(255, 255, 255)
	 * });
	 
]]
local function ProgressBar(props)
	-- Default values
	local direction = props.direction or "horizontal"
	local _condition = props.showLabel
	if _condition == nil then
		_condition = false
	end
	local showLabel = _condition
	local labelColor = props.labelColor or Color3.fromRGB(255, 255, 255)
	local _condition_1 = props.minSize
	if _condition_1 == nil then
		_condition_1 = 4
	end
	local minSize = _condition_1
	local fillColor = props.fillColor or defaultColorScheme.Primary
	local backgroundColor = props.backgroundColor or Color3.fromRGB(40, 40, 40)
	local borderColor = props.borderColor or Color3.fromRGB(100, 100, 100)
	-- Calculate fill percentage
	local fillPercentage = Computed(function()
		local progress = props.currentValue:get()
		local _maxValue = props.maxValue
		if _maxValue ~= nil then
			_maxValue = _maxValue:get()
		end
		local maxValue = _maxValue
		if maxValue ~= nil then
			-- Progress is actual value, calculate percentage
			return if maxValue > 0 then math.clamp(progress / maxValue, 0, 1) else 0
		else
			-- Progress is already a percentage (0-1)
			return math.clamp(progress, 0, 1)
		end
	end)
	-- Calculate fill size based on direction
	local fillSize = Computed(function()
		local percentage = fillPercentage:get()
		if direction == "horizontal" then
			return UDim2.new(percentage, 0, 1, 0)
		else
			-- Vertical - fill from bottom up
			return UDim2.new(1, 0, percentage, 0)
		end
	end)
	-- Calculate fill position for vertical bars (anchor to bottom)
	local fillPosition = Computed(function()
		if direction == "vertical" then
			local percentage = fillPercentage:get()
			return UDim2.new(0, 0, 1 - percentage, 0)
		else
			return UDim2.new(0, 0, 0, 0)
		end
	end)
	-- Generate label text
	local displayText = Computed(function()
		if props.labelText then
			return props.labelText:get()
		end
		local progress = props.currentValue:get()
		local _maxValue = props.maxValue
		if _maxValue ~= nil then
			_maxValue = _maxValue:get()
		end
		local maxValue = _maxValue
		if maxValue ~= nil then
			-- Show current/max format
			return `{math.floor(progress)}/{math.floor(maxValue)}`
		else
			-- Show percentage format
			local percentage = math.floor(fillPercentage:get() * 100)
			return `{percentage}%`
		end
	end)
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_2 = props.Name
	if _condition_2 == nil then
		_condition_2 = "ProgressBar"
	end
	_object[_left] = _condition_2
	_object.Size = props.Size or UDim2.new(1, 0, 0, minSize)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.BackgroundColor3 = backgroundColor
	_object.BorderColor3 = borderColor
	local _left_1 = "BorderSizePixel"
	local _condition_3 = props.BorderSizePixel
	if _condition_3 == nil then
		_condition_3 = 1
	end
	_object[_left_1] = _condition_3
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object[Children] = { New("Frame")({
		Name = "Background",
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundColor3 = defaultColorScheme.Surface,
		BorderSizePixel = 0,
	}), New("Frame")({
		Name = "Fill",
		Size = fillSize,
		Position = fillPosition,
		BackgroundColor3 = fillColor,
		BorderSizePixel = 0,
		ZIndex = 2,
	}), if showLabel then New("TextLabel")({
		Name = "ResourceLabel",
		BackgroundTransparency = 1,
		Text = displayText,
		TextColor3 = labelColor,
		TextScaled = true,
		TextStrokeTransparency = 0,
		TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
		Size = UDim2.new(1, 0, 1, 0),
		Font = Enum.Font.GothamBold,
		ZIndex = 3,
	}) else nil }
	return _fn(_object)
end
return {
	ProgressBar = ProgressBar,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">SlicedImage</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file SlicedImage.ts
	 * @module SlicedImage
	 * @layer Client/UI/Atoms
	 * @description Reusable 9-slice image component for scalable borders, panels, and decorative UI elements.
	 * 
	 * This component provides a clean interface for using 9-slice scaling images, which maintain
	 * proper corner and edge proportions when scaled to different sizes. Perfect for creating
	 * scalable UI panels, borders, and decorative frames.
	 *
	 * @example
	 * // Gothic border frame
	 * const borderFrame = SlicedImage({
	 *   imageId: "rbxassetid://80375133768026",
	 *   sliceCenter: new Rect(130, 130, 130, 130),
	 *   sliceScale: 0.5
	 * });
	 * 
	 * @example
	 * // Colored panel background
	 * const panel = SlicedImage({
	 *   imageId: "rbxassetid://123456789",
	 *   imageColor: Color3.fromRGB(100, 150, 255),
	 *   backgroundColor: Color3.fromRGB(50, 50, 50),
	 *   backgroundTransparency: 0.2
	 * });
	 * 
	 * @example
	 * // Button background with custom slice
	 * const buttonBg = SlicedImage({
	 *   imageId: ImageConstants.Borders.CommonSet,
	 *   sliceCenter: new Rect(64, 64, 64, 64),
	 *   Size: new UDim2(0, 200, 0, 50)
	 * });
	 *
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local New = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src).New
local defaultColorScheme = TS.import(script, script.Parent.Parent, "utils", "theme").defaultColorScheme
--[[
	*
	 * Props interface for the SlicedImage component.
	 * Provides comprehensive configuration for 9-slice image scaling and styling.
	 
]]
--[[
	*
	 * Creates a 9-slice scaled image component for scalable UI elements.
	 * 
	 * This component handles the complexity of 9-slice scaling, allowing images
	 * to be resized while maintaining proper corner and edge proportions. Perfect
	 * for creating panels, borders, and decorative elements that need to scale.
	 * 
	 * @param props - Configuration object for the sliced image
	 * @returns An ImageLabel configured for 9-slice scaling
	 * 
	 * @example
	 * // Basic border frame
	 * const border = SlicedImage({
	 *   imageId: "rbxassetid://80375133768026",
	 *   Size: new UDim2(1, 0, 1, 0)
	 * });
	 * 
	 * @example
	 * // Colored panel with custom slice settings
	 * const panel = SlicedImage({
	 *   imageId: ImageConstants.Borders.GothicMetal,
	 *   sliceCenter: new Rect(130, 130, 130, 130),
	 *   sliceScale: 0.5,
	 *   imageColor: Color3.fromRGB(200, 200, 255),
	 *   Size: new UDim2(0, 300, 0, 200)
	 * });
	 
]]
local function SlicedImage(props)
	-- Default values
	local sliceCenter = props.sliceCenter or Rect.new(64, 64, 64, 64)
	local _condition = props.sliceScale
	if _condition == nil then
		_condition = 1
	end
	local sliceScale = _condition
	local imageColor = props.imageColor or Color3.fromRGB(255, 255, 255)
	local backgroundColor = props.backgroundColor or defaultColorScheme.Surface
	local _condition_1 = props.backgroundTransparency
	if _condition_1 == nil then
		_condition_1 = 1
	end
	local backgroundTransparency = _condition_1
	local _fn = New("ImageLabel")
	local _object = {}
	local _left = "Name"
	local _condition_2 = props.Name
	if _condition_2 == nil then
		_condition_2 = "SlicedImage"
	end
	_object[_left] = _condition_2
	_object.Size = props.Size or UDim2.new(1, 0, 1, 0)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.BackgroundColor3 = backgroundColor
	_object.BackgroundTransparency = backgroundTransparency
	local _left_1 = "BorderSizePixel"
	local _condition_3 = props.BorderSizePixel
	if _condition_3 == nil then
		_condition_3 = 0
	end
	_object[_left_1] = _condition_3
	local _left_2 = "ZIndex"
	local _condition_4 = props.ZIndex
	if _condition_4 == nil then
		_condition_4 = 1
	end
	_object[_left_2] = _condition_4
	_object.LayoutOrder = props.LayoutOrder
	_object.Image = props.imageId
	_object.ImageColor3 = imageColor
	_object.SliceCenter = sliceCenter
	_object.SliceScale = sliceScale
	_object.ScaleType = Enum.ScaleType.Slice
	_object.Visible = props.Visible
	_object.ClipsDescendants = props.ClipsDescendants
	return _fn(_object)
end
return {
	SlicedImage = SlicedImage,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">TabButton</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local defaultColorScheme = TS.import(script, script.Parent.Parent, "utils", "theme").defaultColorScheme
--* Simple tab button atom that toggles active tab via external state 
local function TabButton(tab, active)
	local isActive = Computed(function()
		return active:get() == tab.id
	end)
	local _disabled = tab.disabled
	local isDisabled = if typeof(_disabled) == "boolean" then Value(tab.disabled) else (tab.disabled) or Value(false)
	return New("TextButton")({
		Name = `Tab_{tab.id}`,
		AutomaticSize = Enum.AutomaticSize.XY,
		AutoButtonColor = false,
		Text = tab.label,
		Font = Enum.Font.GothamBold,
		TextSize = 14,
		TextColor3 = Computed(function()
			return if isActive:get() then Color3.fromRGB(255, 255, 255) else Color3.fromRGB(210, 210, 210)
		end),
		BackgroundColor3 = Computed(function()
			return if isActive:get() then defaultColorScheme.Primary else defaultColorScheme.Surface
		end),
		BackgroundTransparency = Computed(function()
			return if isDisabled:get() then 0.4 else 0
		end),
		BorderSizePixel = 0,
		[OnEvent("Activated")] = function()
			if not isDisabled:get() then
				active:set(tab.id)
			end
		end,
		[Children] = {},
	})
end
return {
	TabButton = TabButton,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">TextBox</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file TextBox.ts
	 * @module TextBox
	 * @layer Client/UI/Atoms
	 * @description Reusable text input component with validation, theming, and state management.
	 * 
	 * This component provides a comprehensive text input solution with built-in validation,
	 * focus states, error handling, and theme integration. It supports both single-line and
	 * multiline input modes with customizable styling.
	 *
	 * @example
	 * // Simple text input
	 * const nameInput = TextBox({
	 *   placeholder: "Enter your name...",
	 *   onChanged: (text) => setPlayerName(text)
	 * });
	 * 
	 * @example
	 * // Password input with validation
	 * const passwordInput = TextBox({
	 *   placeholder: "Password",
	 *   validate: (text) => text.length >= 8,
	 *   variant: "error", // Shows red border if validation fails
	 *   onFocusLost: (enterPressed) => {
	 *     if (enterPressed) submitForm();
	 *   }
	 * });
	 * 
	 * @example
	 * // Multiline text area
	 * const messageBox = TextBox({
	 *   placeholder: "Enter your message...",
	 *   multiline: true,
	 *   maxLength: 500,
	 *   size: "large"
	 * });
	 *
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local OnEvent = _fusion.OnEvent
local Value = _fusion.Value
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
--[[
	*
	 * Props interface for the TextBox component.
	 * Provides comprehensive text input configuration with validation and theming.
	 
]]
--[[
	*
	 * Creates a text input component with validation and theming support.
	 * 
	 * This component wraps a TextBox in a styled Frame container to provide
	 * proper theming, padding, and border styling. It handles both controlled
	 * and uncontrolled modes, with built-in validation and error states.
	 * 
	 * @param props - Configuration object for the text input
	 * @returns A Frame containing the styled TextBox with interaction handling
	 * 
	 * @example
	 * // Basic text input
	 * const input = TextBox({
	 *   placeholder: "Type here...",
	 *   onChanged: (text) => handleTextChange(text)
	 * });
	 * 
	 * @example
	 * // Validated email input
	 * const emailInput = TextBox({
	 *   placeholder: "Email address",
	 *   validate: (text) => text.includes("@"),
	 *   variant: "error", // Will show if validation fails
	 *   onFocusLost: (enterPressed) => {
	 *     if (enterPressed) submitEmail();
	 *   }
	 * });
	 
]]
local function TextBox(props)
	-- State management
	local isFocused = Value(false)
	local hasError = Value(false)
	local currentText = props.value or Value("")
	-- Default values
	local _condition = props.placeholder
	if _condition == nil then
		_condition = ""
	end
	local placeholder = _condition
	local _condition_1 = props.multiline
	if _condition_1 == nil then
		_condition_1 = false
	end
	local multiline = _condition_1
	local _condition_2 = props.maxLength
	if _condition_2 == nil then
		_condition_2 = 200
	end
	local maxLength = _condition_2
	local _condition_3 = props.clearTextOnFocus
	if _condition_3 == nil then
		_condition_3 = false
	end
	local clearTextOnFocus = _condition_3
	local variant = props.variant or "default"
	local size = props.size or "medium"
	-- Compute disabled state
	local isDisabled = Computed(function()
		local _disabled = props.disabled
		if type(_disabled) == "boolean" then
			return props.disabled
		elseif props.disabled then
			return props.disabled:get()
		end
		return false
	end)
	-- Get size values
	local getSizeValues = function()
		repeat
			if size == "small" then
				return {
					height = 32,
					paddingX = spacing.sm,
					fontSize = 14,
				}
			end
			if size == "medium" then
				return {
					height = 40,
					paddingX = spacing.md,
					fontSize = 16,
				}
			end
			if size == "large" then
				return {
					height = 48,
					paddingX = spacing.lg,
					fontSize = 18,
				}
			end
			return {
				height = 40,
				paddingX = spacing.md,
				fontSize = 16,
			}
		until true
	end
	local sizeValues = getSizeValues()
	-- Get colors based on variant and state
	local getBorderColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(150, 150, 150)
		end
		if variant == "error" or hasError:get() then
			return defaultColorScheme.Error
		end
		if variant == "success" then
			return defaultColorScheme.Success
		end
		if isFocused:get() then
			return defaultColorScheme.Primary
		end
		return defaultColorScheme.Secondary
	end
	local getBackgroundColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(240, 240, 240)
		end
		return defaultColorScheme.Surface
	end
	local getTextColor = function()
		if isDisabled:get() then
			return Color3.fromRGB(150, 150, 150)
		end
		return defaultColorScheme.OnSurface
	end
	-- Computed styles
	local borderColor = Computed(function()
		return getBorderColor()
	end)
	local backgroundColor = Computed(function()
		return getBackgroundColor()
	end)
	local textColor = Computed(function()
		return getTextColor()
	end)
	local placeholderColor = Computed(function()
		return if isDisabled:get() then Color3.fromRGB(180, 180, 180) else Color3.fromRGB(120, 120, 120)
	end)
	-- Text validation
	local validateText = function(text)
		if props.validate then
			return props.validate(text)
		end
		return true
	end
	-- Create the actual TextBox instance
	local textBoxInstance = New("TextBox")({
		Name = "TextInput",
		Size = UDim2.new(1, -sizeValues.paddingX * 2, 1, 0),
		Position = UDim2.new(0, sizeValues.paddingX, 0, 0),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Text = Computed(function()
			return currentText:get()
		end),
		PlaceholderText = placeholder,
		TextColor3 = textColor,
		PlaceholderColor3 = placeholderColor,
		TextSize = sizeValues.fontSize,
		Font = Enum.Font.Gotham,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = if multiline then Enum.TextYAlignment.Top else Enum.TextYAlignment.Center,
		TextWrapped = multiline,
		MultiLine = multiline,
		MaxVisibleGraphemes = maxLength,
		ClearTextOnFocus = clearTextOnFocus,
		TextEditable = Computed(function()
			return not isDisabled:get()
		end),
		[OnEvent("Focused")] = function()
			isFocused:set(true)
			local _result = props.onFocused
			if _result ~= nil then
				_result()
			end
		end,
		[OnEvent("FocusLost")] = function(enterPressed)
			isFocused:set(false)
			local _result = props.onFocusLost
			if _result ~= nil then
				_result(enterPressed)
			end
		end,
	})
	-- Handle text changes
	textBoxInstance:GetPropertyChangedSignal("Text"):Connect(function()
		local newText = textBoxInstance.Text
		-- Validate text
		local isValid = validateText(newText)
		hasError:set(not isValid)
		-- Update state if it's our internal state
		if not props.value and currentText.set ~= nil then
			currentText:set(newText)
		end
		-- Call change handler
		local _result = props.onChanged
		if _result ~= nil then
			_result(newText)
		end
	end)
	-- Return container frame with TextBox inside
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_4 = props.Name
	if _condition_4 == nil then
		_condition_4 = "TextBox"
	end
	_object[_left] = _condition_4
	_object.Size = props.Size or UDim2.new(1, 0, 0, if multiline then sizeValues.height * 3 else sizeValues.height)
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.BackgroundColor3 = backgroundColor
	_object.BackgroundTransparency = 0
	_object.BorderSizePixel = 2
	_object.BorderColor3 = borderColor
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object[Children] = { textBoxInstance }
	_object.Visible = props.Visible
	_object.ClipsDescendants = props.ClipsDescendants
	return _fn(_object)
end
return {
	TextBox = TextBox,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="14">
        <Properties>
          <string name="Name">examples</string>
        </Properties>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">ExampleUsage</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file ExampleUsage.ts
	 * @description Comprehensive example demonstrating all SS-Fusion atoms with proper usage patterns.
	 * 
	 * This example showcases:
	 * - Unified Button component (text, icon, and styled variants)
	 * - Label component with different typography variants
	 * - TextBox component with validation and state management
	 * - ProgressBar component with reactive progress tracking
	 * - SlicedImage component for scalable UI panels
	 * - Proper reactive state management with Fusion
	 * - Theme integration and consistent styling
	 * 
	 * @example
	 * // To use this example in your game:
	 * const demoUI = CreateExampleUI();
	 * demoUI.Parent = PlayerGui.ScreenGui;
	 * 
	 * @author Soul Steel Alpha Development Team
	 * @since 1.0.0
	 
]]
local Value = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src).Value
local _atoms = TS.import(script, script.Parent.Parent, "atoms")
local Label = _atoms.Label
local Button = _atoms.Button
local TextBox = _atoms.TextBox
local ProgressBar = _atoms.ProgressBar
local SlicedImage = _atoms.SlicedImage
local _image_assets = TS.import(script, script.Parent.Parent, "types", "image-assets")
local ImageConstants = _image_assets.ImageConstants
local MenuButtonImageMap = _image_assets.MenuButtonImageMap
--[[
	*
	 * Creates a comprehensive UI demo showcasing all SS-Fusion atoms.
	 * 
	 * This function demonstrates proper usage patterns including:
	 * - Reactive state management with Fusion Values
	 * - Component composition and layout
	 * - Event handling and user interactions
	 * - Theme integration and consistent styling
	 * 
	 * @returns A Frame containing the complete demo UI
	 
]]
local function CreateExampleUI()
	-- Reactive state values for demo interactivity
	local inputText = Value("")
	local displayText = Value("Hello, World!")
	local progressValue = Value(0.75)
	-- Main container with dark background
	local container = Instance.new("Frame")
	container.Size = UDim2.new(1, 0, 1, 0)
	container.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	-- === TYPOGRAPHY DEMONSTRATION ===
	-- Main heading using Label component
	local header = Label({
		Name = "Header",
		text = "SS-Fusion Component Demo",
		variant = "heading",
		Size = UDim2.new(1, 0, 0, 50),
		Position = UDim2.new(0, 0, 0, 10),
	})
	-- === PROGRESS VISUALIZATION ===
	-- Progress bar demonstrating reactive progress tracking
	local progressBar = ProgressBar({
		Name = "ExampleProgress",
		currentValue = progressValue,
		maxValue = Value(1),
		showLabel = true,
		Size = UDim2.new(0.8, 0, 0, 20),
		Position = UDim2.new(0.1, 0, 0, 70),
	})
	-- === TEXT INPUT DEMONSTRATION ===
	-- Text input with placeholder and change handling
	local textInput = TextBox({
		Name = "TextInput",
		placeholder = "Enter some text...",
		value = inputText,
		Size = UDim2.new(0.8, 0, 0, 40),
		Position = UDim2.new(0.1, 0, 0, 100),
		onChanged = function(text)
			-- Update display text in real-time as user types
			print("Text changed:", text)
		end,
	})
	-- === REACTIVE TEXT DISPLAY ===
	-- Label that displays reactive text content
	local displayLabel = Label({
		Name = "DisplayLabel",
		text = displayText,
		variant = "body",
		Size = UDim2.new(0.8, 0, 0, 30),
		Position = UDim2.new(0.1, 0, 0, 150),
	})
	-- === BUTTON DEMONSTRATIONS ===
	-- Primary action button (text button)
	local primaryButton = Button({
		Name = "PrimaryButton",
		text = "Update Display",
		variant = "primary",
		Size = UDim2.new(0, 150, 0, 40),
		Position = UDim2.new(0.1, 0, 0, 190),
		onClick = function()
			-- Update display text with input content or default message
			local _condition = inputText:get()
			if not (_condition ~= "" and _condition) then
				_condition = "Nothing entered!"
			end
			displayText:set(_condition)
		end,
	})
	-- Secondary action button (text button)
	local secondaryButton = Button({
		Name = "SecondaryButton",
		text = "Clear All",
		variant = "secondary",
		Size = UDim2.new(0, 150, 0, 40),
		Position = UDim2.new(0.1, 200, 0, 190),
		onClick = function()
			-- Reset all demo values to defaults
			inputText:set("")
			displayText:set("Cleared!")
		end,
	})
	-- Icon button demonstration (unified button in icon mode)
	local iconButton = Button({
		Name = "IconButton",
		icon = MenuButtonImageMap.Settings,
		variant = "icon",
		size = "medium",
		Position = UDim2.new(0.1, 370, 0, 190),
		onClick = function()
			print("Icon button clicked!")
		end,
	})
	-- === SLICED IMAGE DEMONSTRATION ===
	-- Background panel using 9-slice scaling for scalable borders
	local backgroundPanel = SlicedImage({
		Name = "BackgroundPanel",
		imageId = ImageConstants.Borders.GothicMetal,
		Size = UDim2.new(0.8, 0, 0, 100),
		Position = UDim2.new(0.1, 0, 0, 250),
		sliceCenter = Rect.new(130, 130, 130, 130),
		sliceScale = 0.5,
	})
	-- === ASSEMBLY ===
	-- Add all components to the main container
	header.Parent = container
	progressBar.Parent = container
	textInput.Parent = container
	displayLabel.Parent = container
	primaryButton.Parent = container
	secondaryButton.Parent = container
	iconButton.Parent = container
	backgroundPanel.Parent = container
	return container
end
return {
	CreateExampleUI = CreateExampleUI,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">TabGroupExample</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local New = _fusion.New
local Value = _fusion.Value
local TabGroup = TS.import(script, script.Parent.Parent, "organisms", "TabGroup").TabGroup
--[[
	*
	 * Simple example demonstrating the TabGroup organism.
	 * Returns a container Frame with a TabGroup inside.
	 
]]
local function CreateTabGroupExample()
	local active = Value("Inventory")
	local tabs = { {
		id = "Inventory",
		label = "Inventory",
		panel = function()
			return New("TextLabel")({
				Text = "Inventory Panel",
				Size = UDim2.fromScale(1, 1),
				BackgroundTransparency = 1,
				TextScaled = true,
			})
		end,
	}, {
		id = "Skills",
		label = "Skills",
		panel = function()
			return New("TextLabel")({
				Text = "Skills Panel",
				Size = UDim2.fromScale(1, 1),
				BackgroundTransparency = 1,
				TextScaled = true,
			})
		end,
	}, {
		id = "Character",
		label = "Character",
		panel = function()
			return New("TextLabel")({
				Text = "Character Panel",
				Size = UDim2.fromScale(1, 1),
				BackgroundTransparency = 1,
				TextScaled = true,
			})
		end,
	} }
	local container = Instance.new("Frame")
	container.Name = "TabGroupExample"
	container.Size = UDim2.new(0, 480, 0, 220)
	container.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	local tabGroup = TabGroup({
		Name = "DemoTabs",
		Size = UDim2.new(1, -40, 1, -40),
		Position = UDim2.new(0, 20, 0, 20),
		active = active,
		tabs = tabs,
		layout = "Top",
		mountOnlyActive = false,
	})
	tabGroup.Parent = container
	return container
end
return {
	CreateTabGroupExample = CreateTabGroupExample,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="17">
        <Properties>
          <string name="Name">integration-test</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * Integration test file to verify all new components are properly exported and functional
	 
]]
local _index = TS.import(script, script.Parent)
local IconButton = _index.IconButton
local CloseButton = _index.CloseButton
local MessageBox = _index.MessageBox
local TitleBar = _index.TitleBar
local CooldownButton = _index.CooldownButton
-- Test that all components can be imported and used
local function testIntegration()
	-- Test IconButton
	local iconButton = IconButton({
		icon = "rbxassetid://123456789",
		variant = "primary",
		size = "medium",
		onClick = function()
			return print("IconButton clicked!")
		end,
	})
	-- Test CloseButton
	local closeButton = CloseButton({
		variant = "error",
		onClick = function()
			return print("Close clicked!")
		end,
	})
	-- Test MessageBox
	local messageBox = MessageBox({
		message = "Test message",
		messageType = "success",
		autoHide = true,
		duration = 3,
	})
	-- Test TitleBar
	local titleBar = TitleBar({
		title = "Test Dialog",
		variant = "primary",
		onClose = function()
			return print("Dialog closed!")
		end,
	})
	-- Test CooldownButton
	local cooldownButton = CooldownButton({
		icon = "rbxassetid://987654321",
		cooldown = 5,
		variant = "accent",
		onClick = function()
			return print("Cooldown button clicked!")
		end,
	})
	return {
		iconButton = iconButton,
		closeButton = closeButton,
		messageBox = messageBox,
		titleBar = titleBar,
		cooldownButton = cooldownButton,
	}
end
return {
	testIntegration = testIntegration,
}
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="18">
        <Properties>
          <string name="Name">layout</string>
        </Properties>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">Grid</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * Grid.ts
	 * UIGridLayout wrapper for simple uniform grids and optional responsive columns.
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local New = _fusion.New
local Value = _fusion.Value
local function Grid(props)
	local _fn = New("UIGridLayout")
	local _object = {
		CellSize = props.cellSize,
		CellPadding = props.cellPadding or UDim2.new(0, 8, 0, 8),
	}
	local _left = "FillDirectionMaxCells"
	local _condition = props.fillDirectionMaxCells
	if _condition == nil then
		_condition = 0
	end
	_object[_left] = _condition
	_object.FillDirection = props.fillDirection or Enum.FillDirection.Horizontal
	_object.SortOrder = props.sortOrder or Enum.SortOrder.LayoutOrder
	local grid = _fn(_object)
	local _fn_1 = New("Frame")
	local _object_1 = {}
	local _left_1 = "Name"
	local _condition_1 = props.Name
	if _condition_1 == nil then
		_condition_1 = "Grid"
	end
	_object_1[_left_1] = _condition_1
	local _left_2 = "BackgroundTransparency"
	local _condition_2 = props.BackgroundTransparency
	if _condition_2 == nil then
		_condition_2 = 1
	end
	_object_1[_left_2] = _condition_2
	_object_1.BackgroundColor3 = props.BackgroundColor3
	local _left_3 = "BorderSizePixel"
	local _condition_3 = props.BorderSizePixel
	if _condition_3 == nil then
		_condition_3 = 0
	end
	_object_1[_left_3] = _condition_3
	_object_1.Size = props.Size or UDim2.fromScale(1, 1)
	_object_1.Position = props.Position
	_object_1.AnchorPoint = props.AnchorPoint
	_object_1.ZIndex = props.ZIndex
	_object_1.LayoutOrder = props.LayoutOrder
	_object_1.Visible = props.Visible
	local _left_4 = Children
	local _array = { grid }
	local _length = #_array
	local _array_1 = (props.children or {})
	table.move(_array_1, 1, #_array_1, _length + 1, _array)
	_object_1[_left_4] = _array
	local container = _fn_1(_object_1)
	return container
end
--* AutoGrid picks a column count based on container width and clamps cell size 
local function AutoGrid(props)
	local _condition = props.minCellPx
	if _condition == nil then
		_condition = 64
	end
	local minPx = _condition
	local _condition_1 = props.maxCellPx
	if _condition_1 == nil then
		_condition_1 = 128
	end
	local maxPx = _condition_1
	local widthState = Value(0)
	local cellSize = Computed(function()
		local w = widthState:get()
		if w <= 0 then
			return UDim2.new(0, minPx, 0, minPx)
		end
		local pad = if props.cellPadding then props.cellPadding.X.Offset else 8
		local cols = math.max(1, math.floor(w / (maxPx + pad)))
		local usable = math.max(1, w - pad * math.max(0, cols - 1))
		local px = math.clamp(math.floor(usable / cols), minPx, maxPx)
		return UDim2.new(0, px, 0, px)
	end)
	local _object = table.clone(props)
	setmetatable(_object, nil)
	_object.cellSize = cellSize
	local container = Grid(_object)
	-- Track AbsoluteSize to recompute cell size
	local updateWidth = function()
		return widthState:set(container.AbsoluteSize.X)
	end
	local conn = container:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateWidth)
	if container.Destroying then
		container.Destroying:Connect(function()
			return conn:Disconnect()
		end)
	end
	-- Initialize after parented (AbsoluteSize is 0 until mounted); also try now
	task.defer(updateWidth)
	updateWidth()
	return container
end
return {
	Grid = Grid,
	AutoGrid = AutoGrid,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">Stack</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * Stack.ts
	 * Simple horizontal/vertical stacks using UIListLayout + UIPadding with gap and alignment.
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local New = _fusion.New
local spacing = TS.import(script, script.Parent.Parent, "utils", "theme").spacing
local function toHorizontalAlignment(justify)
	repeat
		if justify == "center" then
			return Enum.HorizontalAlignment.Center
		end
		if justify == "end" then
			return Enum.HorizontalAlignment.Right
		end
		return Enum.HorizontalAlignment.Left
	until true
end
local function toVerticalAlignment(align)
	repeat
		if align == "center" then
			return Enum.VerticalAlignment.Center
		end
		if align == "end" then
			return Enum.VerticalAlignment.Bottom
		end
		return Enum.VerticalAlignment.Top
	until true
end
local function toHorizontalAlignmentFromAlign(align)
	repeat
		if align == "center" then
			return Enum.HorizontalAlignment.Center
		end
		if align == "end" then
			return Enum.HorizontalAlignment.Right
		end
		return Enum.HorizontalAlignment.Left
	until true
end
local function toVerticalAlignmentFromJustify(justify)
	repeat
		if justify == "center" then
			return Enum.VerticalAlignment.Center
		end
		if justify == "end" then
			return Enum.VerticalAlignment.Bottom
		end
		return Enum.VerticalAlignment.Top
	until true
end
local function Stack(props)
	local direction = props.direction or "row"
	local _condition = props.gap
	if _condition == nil then
		_condition = spacing.sm
	end
	local gap = _condition
	local _condition_1 = props.padding
	if _condition_1 == nil then
		_condition_1 = 0
	end
	local pad = _condition_1
	local align = props.align or "center"
	local justify = props.justify or "start"
	local horizontal = direction == "row"
	local layout = New("UIListLayout")({
		FillDirection = if horizontal then Enum.FillDirection.Horizontal else Enum.FillDirection.Vertical,
		Padding = UDim.new(0, gap),
		SortOrder = Enum.SortOrder.LayoutOrder,
		HorizontalAlignment = if horizontal then toHorizontalAlignment(justify) else toHorizontalAlignmentFromAlign(align),
		VerticalAlignment = if horizontal then toVerticalAlignment(align) else toVerticalAlignmentFromJustify(justify),
	})
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_2 = props.Name
	if _condition_2 == nil then
		_condition_2 = (if horizontal then "HStack" else "VStack")
	end
	_object[_left] = _condition_2
	local _left_1 = "BackgroundTransparency"
	local _condition_3 = props.BackgroundTransparency
	if _condition_3 == nil then
		_condition_3 = 1
	end
	_object[_left_1] = _condition_3
	_object.BackgroundColor3 = props.BackgroundColor3
	local _left_2 = "BorderSizePixel"
	local _condition_4 = props.BorderSizePixel
	if _condition_4 == nil then
		_condition_4 = 0
	end
	_object[_left_2] = _condition_4
	_object.Size = props.Size or UDim2.fromScale(1, 0)
	_object.AutomaticSize = if horizontal then Enum.AutomaticSize.Y else Enum.AutomaticSize.X
	_object.Position = props.Position
	_object.AnchorPoint = props.AnchorPoint
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object.Visible = props.Visible
	local _left_3 = Children
	local _array = { New("UIPadding")({
		PaddingLeft = UDim.new(0, pad),
		PaddingRight = UDim.new(0, pad),
		PaddingTop = UDim.new(0, pad),
		PaddingBottom = UDim.new(0, pad),
	}), layout }
	local _length = #_array
	local _array_1 = (props.children or {})
	table.move(_array_1, 1, #_array_1, _length + 1, _array)
	_object[_left_3] = _array
	local container = _fn(_object)
	-- Note: true space-between distribution is not supported by UIListLayout.
	-- If requested, we gracefully fall back via the alignment mapping above.
	return container
end
local function Spacer(props)
	local direction = props.direction or "row"
	local isRow = direction == "row"
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition = props.Name
	if _condition == nil then
		_condition = "Spacer"
	end
	_object[_left] = _condition
	_object.BackgroundTransparency = 1
	_object.BorderSizePixel = 0
	local _left_1 = "Size"
	local _value = props.size
	_object[_left_1] = if _value ~= 0 and _value == _value and _value then (if isRow then UDim2.new(0, props.size, 1, 0) else UDim2.new(1, 0, 0, props.size)) else (if isRow then UDim2.new(1, 0, 0, 0) else UDim2.new(0, 0, 1, 0))
	_object.AutomaticSize = Enum.AutomaticSize.None
	return _fn(_object)
end
local function HStack(props)
	local _object = table.clone(props)
	setmetatable(_object, nil)
	_object.direction = "row"
	return Stack(_object)
end
local function VStack(props)
	local _object = table.clone(props)
	setmetatable(_object, nil)
	_object.direction = "column"
	return Stack(_object)
end
return {
	Stack = Stack,
	Spacer = Spacer,
	HStack = HStack,
	VStack = VStack,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="21">
        <Properties>
          <string name="Name">molecules</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "CooldownButton") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TabBar") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TabPanels") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "TitleBar") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">CooldownButton</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file CooldownButton.ts
	 * @module CooldownButton
	 * @layer Client/UI/Molecules
	 * @description Enhanced button component with integrated cooldown timer and progress visualization.
	 *
	 * Combines an IconButton with a ProgressBar to create a complete cooldown system
	 * suitable for abilities, actions, or any time-based interactions. Fully integrated
	 * with the ss-fusion theme system.
	 *
	 * @example
	 * // Basic cooldown button
	 * const button = CooldownButton({
	 *   icon: "rbxassetid://123456789",
	 *   cooldown: 5, // 5 seconds
	 *   onClick: () => castSpell()
	 * });
	 *
	 * @example
	 * // Themed cooldown button
	 * const button = CooldownButton({
	 *   icon: "rbxassetid://123456789",
	 *   cooldown: 10,
	 *   variant: "primary",
	 *   size: "large",
	 *   onClick: () => performAction()
	 * });
	 *
	 * @author SS-Fusion Development Team
	 * @since 2.1.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Value = _fusion.Value
local New = _fusion.New
local Computed = _fusion.Computed
local OnEvent = _fusion.OnEvent
local Children = _fusion.Children
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
local ProgressBar = TS.import(script, script.Parent.Parent, "atoms", "ProgressBar").ProgressBar
--[[
	*
	 * Size configuration mapping
	 
]]
local sizeConfig = {
	small = {
		container = UDim2.new(0, 40, 0, 50),
		button = UDim2.new(1, 0, 0, 32),
		progressBar = UDim2.new(1, 0, 0, 6),
	},
	medium = {
		container = UDim2.new(0, 56, 0, 70),
		button = UDim2.new(1, 0, 0, 48),
		progressBar = UDim2.new(1, 0, 0, 8),
	},
	large = {
		container = UDim2.new(0, 72, 0, 90),
		button = UDim2.new(1, 0, 0, 64),
		progressBar = UDim2.new(1, 0, 0, 10),
	},
}
--[[
	*
	 * Get theme colors for variant
	 
]]
local function getVariantColors(variant)
	repeat
		if variant == "primary" then
			return {
				button = defaultColorScheme.Primary,
				progress = defaultColorScheme.Primary:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Primary:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		if variant == "secondary" then
			return {
				button = defaultColorScheme.Secondary,
				progress = defaultColorScheme.Secondary:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Secondary:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		if variant == "accent" then
			return {
				button = defaultColorScheme.Accent,
				progress = defaultColorScheme.Accent:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Accent:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		if variant == "error" then
			return {
				button = defaultColorScheme.Error,
				progress = defaultColorScheme.Error:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Error:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		if variant == "success" then
			return {
				button = defaultColorScheme.Success,
				progress = defaultColorScheme.Success:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Success:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		if variant == "warning" then
			return {
				button = defaultColorScheme.Warning,
				progress = defaultColorScheme.Warning:Lerp(Color3.fromRGB(255, 255, 255), 0.3),
				disabled = defaultColorScheme.Warning:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
			}
		end
		return {
			button = defaultColorScheme.Surface,
			progress = defaultColorScheme.OnSurface,
			disabled = defaultColorScheme.OnSurface:Lerp(Color3.fromRGB(128, 128, 128), 0.5),
		}
	until true
end
local function CooldownButton(props)
	-- State values
	local cooldownRemaining = Value(0)
	local isHovered = Value(false)
	local isPressed = Value(false)
	local _condition = props.initiallyDisabled
	if _condition == nil then
		_condition = false
	end
	local isDisabled = Value(_condition)
	-- Configuration
	local size = props.size or "medium"
	local variant = props.variant or "primary"
	local themeColors = getVariantColors(variant)
	local sizes = sizeConfig[size]
	-- Computed values
	local cooldownProgress = Computed(function()
		return if props.cooldown > 0 then cooldownRemaining:get() / props.cooldown else 0
	end)
	local isOnCooldown = Computed(function()
		return cooldownProgress:get() > 0
	end)
	local canClick = Computed(function()
		return not isOnCooldown:get() and not isDisabled:get()
	end)
	-- Cooldown management
	local function startCooldown()
		if props.cooldown <= 0 then
			return nil
		end
		cooldownRemaining:set(props.cooldown)
		local interval = 0.1
		local updateTask = task.spawn(function()
			while cooldownRemaining:get() > 0 do
				task.wait(interval)
				local newValue = math.max(0, cooldownRemaining:get() - interval)
				cooldownRemaining:set(newValue)
				if newValue <= 0 then
					local _result = props.onCooldownComplete
					if _result ~= nil then
						_result()
					end
					break
				end
			end
		end)
		return updateTask
	end
	-- Icon button
	local IconButtonComponent = New("ImageButton")({
		Name = "CooldownButtonIcon",
		Size = sizes.button,
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = Computed(function()
			if not canClick:get() then
				return themeColors.disabled
			elseif isPressed:get() then
				return themeColors.button:Lerp(Color3.fromRGB(0, 0, 0), 0.2)
			elseif isHovered:get() then
				return themeColors.button:Lerp(Color3.fromRGB(255, 255, 255), 0.1)
			else
				return themeColors.button
			end
		end),
		BackgroundTransparency = 0.1,
		BorderSizePixel = 0,
		AutoButtonColor = false,
		Image = props.icon,
		ImageColor3 = Computed(function()
			return if canClick:get() then Color3.fromRGB(255, 255, 255) else Color3.fromRGB(160, 160, 160)
		end),
		ImageTransparency = Computed(function()
			return if canClick:get() then 0 else 0.5
		end),
		[OnEvent("MouseEnter")] = function()
			if canClick:get() then
				isHovered:set(true)
				local _result = props.onHover
				if _result ~= nil then
					_result()
				end
				local _result_1 = props.OnMouseEnter
				if _result_1 ~= nil then
					_result_1()
				end
			end
		end,
		[OnEvent("MouseLeave")] = function()
			isHovered:set(false)
			isPressed:set(false)
			local _result = props.OnMouseLeave
			if _result ~= nil then
				_result()
			end
		end,
		[OnEvent("MouseButton1Down")] = function()
			if canClick:get() then
				isPressed:set(true)
			end
		end,
		[OnEvent("MouseButton1Up")] = function()
			isPressed:set(false)
		end,
		[OnEvent("Activated")] = function()
			if canClick:get() then
				local _result = props.onClick
				if _result ~= nil then
					_result()
				end
				local _result_1 = props.OnActivated
				if _result_1 ~= nil then
					_result_1()
				end
				startCooldown()
			end
		end,
	})
	-- Progress bar for cooldown
	local baseBarHeight = sizes.progressBar.Y.Offset
	local effectiveBarHeight = if props.showCooldownLabel then math.max(baseBarHeight, 14) else baseBarHeight
	local _object = {
		Size = UDim2.new(1, 0, 0, effectiveBarHeight),
		Position = UDim2.new(0, 0, 1, -effectiveBarHeight - spacing.xs),
		currentValue = cooldownRemaining,
		maxValue = Value(props.cooldown),
		fillColor = themeColors.progress,
		direction = "horizontal",
	}
	local _left = "showLabel"
	local _condition_1 = props.showCooldownLabel
	if _condition_1 == nil then
		_condition_1 = false
	end
	_object[_left] = _condition_1
	_object.labelText = props.cooldownLabelText
	_object.labelColor = props.cooldownLabelColor
	local CooldownProgressBar = ProgressBar(_object)
	-- Main container
	local cooldownButtonContainer = New("Frame")({
		Name = "CooldownButton",
		Size = props.Size or sizes.container,
		Position = props.Position,
		AnchorPoint = props.AnchorPoint,
		LayoutOrder = props.LayoutOrder,
		ZIndex = props.ZIndex,
		Visible = props.Visible,
		BackgroundTransparency = 1,
		[Children] = {
			IconButton = IconButtonComponent,
			ProgressBar = CooldownProgressBar,
		},
	})
	return cooldownButtonContainer
end
return {
	CooldownButton = CooldownButton,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="23">
          <Properties>
            <string name="Name">TabBar</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local ForPairs = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src).ForPairs
local TabButton = TS.import(script, script.Parent.Parent, "atoms", "TabButton").TabButton
local _Stack = TS.import(script, script.Parent.Parent, "layout", "Stack")
local HStack = _Stack.HStack
local VStack = _Stack.VStack
local function TabBar(props)
	local size = if props.vertical then UDim2.new(0, 140, 1, 0) else UDim2.new(1, 0, 0, 36)
	local StackComp = if props.vertical then VStack else HStack
	return StackComp({
		Name = "TabBar",
		BackgroundTransparency = 1,
		Size = size,
		AutomaticSize = if props.vertical then Enum.AutomaticSize.X else Enum.AutomaticSize.Y,
		gap = 6,
		align = if props.vertical then "start" else "center",
		justify = "start",
		children = { ForPairs(props.tabs, function(_i, tab)
			return tab.id, TabButton(tab, props.active)
		end) },
	})
end
return {
	TabBar = TabBar,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="24">
          <Properties>
            <string name="Name">TabPanels</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local Computed = _fusion.Computed
local ForPairs = _fusion.ForPairs
local New = _fusion.New
local function KeepMountedPanels(tabs, active)
	return New("Frame")({
		Name = "Panels",
		BackgroundTransparency = 1,
		Size = UDim2.fromScale(1, 1),
		[Children] = { ForPairs(tabs, function(_i, tab)
			local visible = Computed(function()
				return active:get() == tab.id
			end)
			return `{tab.id}_PanelWrap`, New("Frame")({
				Name = `{tab.id}_Wrap`,
				BackgroundTransparency = 1,
				Size = UDim2.fromScale(1, 1),
				Visible = visible,
				[Children] = { tab.panel() },
			})
		end) },
	})
end
local function MountOnlyActivePanels(tabs, active)
	local byId = {}
	for _, t in tabs do
		local _id = t.id
		local _panel = t.panel
		byId[_id] = _panel
	end
	return New("Frame")({
		Name = "Panels",
		BackgroundTransparency = 1,
		Size = UDim2.fromScale(1, 1),
		[Children] = Computed(function()
			local id = active:get()
			local create = byId[id]
			local child = if create then create() else nil
			return if child then { child } else {}
		end),
	})
end
local function TabPanels(props)
	return if props.mountOnlyActive then MountOnlyActivePanels(props.tabs, props.active) else KeepMountedPanels(props.tabs, props.active)
end
return {
	TabPanels = TabPanels,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="25">
          <Properties>
            <string name="Name">TitleBar</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--[[
	*
	 * @file TitleBar.ts
	 * @module TitleBar
	 * @layer Client/UI/Molecules
	 * @description Window title bar component with title text and optional close button.
	 *
	 * A reusable title bar component that combines a title label with an optional close button.
	 * Perfect for dialogs, modals, and any interface that needs a header with close functionality.
	 * Fully integrated with the ss-fusion theme system.
	 *
	 * @example
	 * // Basic title bar
	 * const titleBar = TitleBar({
	 *   title: "Settings",
	 *   onClose: () => closeDialog()
	 * });
	 *
	 * @example
	 * // Customized title bar
	 * const titleBar = TitleBar({
	 *   title: "Advanced Options",
	 *   variant: "primary",
	 *   height: 40,
	 *   showCloseButton: true,
	 *   onClose: () => handleClose()
	 * });
	 *
	 * @author SS-Fusion Development Team
	 * @since 2.1.0
	 
]]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local New = _fusion.New
local Computed = _fusion.Computed
local _theme = TS.import(script, script.Parent.Parent, "utils", "theme")
local defaultColorScheme = _theme.defaultColorScheme
local spacing = _theme.spacing
local borderRadiusValues = _theme.borderRadiusValues
local fontSizes = _theme.fontSizes
local CloseButton = TS.import(script, script.Parent.Parent, "atoms", "CloseButton").CloseButton
--[[
	*
	 * Get theme colors for variant
	 
]]
local function getVariantColors(variant)
	repeat
		if variant == "primary" then
			return {
				background = defaultColorScheme.Primary,
				text = defaultColorScheme.OnPrimary,
				border = defaultColorScheme.Primary:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		if variant == "secondary" then
			return {
				background = defaultColorScheme.Secondary,
				text = defaultColorScheme.OnSecondary,
				border = defaultColorScheme.Secondary:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		if variant == "accent" then
			return {
				background = defaultColorScheme.Accent,
				text = defaultColorScheme.OnPrimary,
				border = defaultColorScheme.Accent:Lerp(Color3.fromRGB(0, 0, 0), 0.2),
			}
		end
		return {
			background = defaultColorScheme.Surface,
			text = defaultColorScheme.OnSurface,
			border = defaultColorScheme.OnSurface:Lerp(Color3.fromRGB(255, 255, 255), 0.8),
		}
	until true
end
--[[
	*
	 * TitleBar component
	 
]]
local function TitleBar(props)
	local _condition = props.height
	if _condition == nil then
		_condition = 32
	end
	local height = _condition
	local variant = props.variant or "secondary"
	local _condition_1 = props.showCloseButton
	if _condition_1 == nil then
		_condition_1 = true
	end
	local showCloseButton = _condition_1
	local themeColors = getVariantColors(variant)
	-- Get title text (handle both string and Value<string>)
	local titleText = Computed(function()
		local _title = props.title
		if type(_title) == "string" then
			return props.title
		else
			return props.title:get()
		end
	end)
	-- Title label
	local TitleLabel = New("TextLabel")({
		Name = "TitleLabel",
		Size = UDim2.new(1, if showCloseButton then -height else -spacing.md, 1, 0),
		Position = UDim2.new(0, spacing.md, 0, 0),
		BackgroundTransparency = 1,
		Text = titleText,
		TextColor3 = props.textColor or themeColors.text,
		TextSize = fontSizes.md,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Center,
		TextTruncate = Enum.TextTruncate.AtEnd,
		Font = Enum.Font.SourceSansSemibold,
	})
	-- Close button (optional)
	local closeButton = if showCloseButton and props.onClose then CloseButton({
		Size = UDim2.new(0, height - spacing.xs, 0, height - spacing.xs),
		Position = UDim2.new(1, -spacing.sm, 0.5, 0),
		AnchorPoint = Vector2.new(1, 0.5),
		variant = if variant == "primary" or variant == "accent" then "secondary" else variant,
		onClick = props.onClose,
	}) else nil
	-- Main title bar container
	local titleBarContainer = New("Frame")({
		Name = "TitleBar",
		Size = props.Size or UDim2.new(1, 0, 0, height),
		Position = props.Position,
		AnchorPoint = props.AnchorPoint,
		LayoutOrder = props.LayoutOrder,
		ZIndex = props.ZIndex,
		Visible = props.Visible,
		BackgroundColor3 = props.backgroundColor or themeColors.background,
		BorderSizePixel = 1,
		BorderColor3 = themeColors.border,
		BorderMode = Enum.BorderMode.Inset,
		[Children] = {
			Corner = New("UICorner")({
				CornerRadius = UDim.new(0, borderRadiusValues.small),
			}),
			TitleLabel = TitleLabel,
			CloseButton = closeButton,
		},
	})
	return titleBarContainer
end
return {
	TitleBar = TitleBar,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="26">
        <Properties>
          <string name="Name">organisms</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "TabGroup") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">TabGroup</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local _fusion = TS.import(script, TS.getModule(script, "@rbxts", "fusion").src)
local Children = _fusion.Children
local New = _fusion.New
local TabBar = TS.import(script, script.Parent.Parent, "molecules", "TabBar").TabBar
local TabPanels = TS.import(script, script.Parent.Parent, "molecules", "TabPanels").TabPanels
local function TabGroup(props)
	local vertical = props.layout == "Left"
	-- Ensure active is valid (fall back to first tab)
	local _condition = #props.tabs > 0
	if _condition then
		local _exp = props.tabs
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		local _callback = function(t)
			return t.id == props.active:get()
		end
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		_condition = not _result
	end
	if _condition then
		props.active:set(props.tabs[1].id)
	end
	local barSize = if vertical then UDim2.new(0, 140, 1, 0) else UDim2.new(1, 0, 0, 36)
	local panelsPos = if vertical then UDim2.new(0, 140, 0, 0) else UDim2.new(0, 0, 0, 36)
	local panelsSize = if vertical then UDim2.new(1, -140, 1, 0) else UDim2.new(1, 0, 1, -36)
	local _fn = New("Frame")
	local _object = {}
	local _left = "Name"
	local _condition_1 = props.Name
	if _condition_1 == nil then
		_condition_1 = "TabGroup"
	end
	_object[_left] = _condition_1
	_object.BackgroundTransparency = 1
	_object.Size = props.Size or UDim2.fromScale(1, 1)
	_object.Position = props.Position or UDim2.fromOffset(0, 0)
	_object.AnchorPoint = props.AnchorPoint
	_object.ZIndex = props.ZIndex
	_object.LayoutOrder = props.LayoutOrder
	_object.Visible = props.Visible
	_object[Children] = { New("Frame")({
		Name = "Bar",
		BackgroundTransparency = 1,
		Size = barSize,
		[Children] = { TabBar({
			tabs = props.tabs,
			active = props.active,
			vertical = vertical,
		}) },
	}), New("Frame")({
		Name = "Content",
		BackgroundTransparency = 1,
		Position = panelsPos,
		Size = panelsSize,
		[Children] = { TabPanels({
			tabs = props.tabs,
			active = props.active,
			mountOnlyActive = props.mountOnlyActive,
		}) },
	}) }
	return _fn(_object)
end
return {
	TabGroup = TabGroup,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="28">
        <Properties>
          <string name="Name">templates</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="29">
        <Properties>
          <string name="Name">tests</string>
        </Properties>
        <Item class="Folder" referent="30">
          <Properties>
            <string name="Name">helpers</string>
          </Properties>
          <Item class="LocalScript" referent="31">
            <Properties>
              <string name="Name">bootstrap</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--/ <reference types="@rbxts/testez/globals" />
local TestEZ = TS.import(script, TS.getModule(script, "@rbxts", "testez").src)
local results = TestEZ.TestBootstrap:run({ script })
print(`[ss-fusion] Test run: success={results.successCount} failure={results.failureCount} skipped={results.skippedCount}`)
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="32">
          <Properties>
            <string name="Name">unit</string>
          </Properties>
          <Item class="Folder" referent="33">
            <Properties>
              <string name="Name">atoms</string>
            </Properties>
            <Item class="ModuleScript" referent="34">
              <Properties>
                <string name="Name">Button.spec</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--/ <reference types="@rbxts/testez/globals" />
local Button = TS.import(script, script.Parent.Parent.Parent.Parent.Parent.Parent, "ReplicatedStorage", "TS", "atoms", "Button").Button
return function()
	describe("Button", function()
		it("creates a Frame with InteractionButton", function()
			local frame = Button({
				text = "Click me",
			})
			expect(frame:IsA("Frame")).to.equal(true)
			expect(frame:FindFirstChild("InteractionButton")).to.be.ok()
			frame:Destroy()
		end)
	end)
end
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="35">
        <Properties>
          <string name="Name">types</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "ui-constants") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "image-assets") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "tabs") or {} do
	exports[_k] = _v
end
return exports
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">common-new</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * Base props that all components should extend from
	 
]]
--[[
	*
	 * Props for components that can be interacted with
	 
]]
--[[
	*
	 * Common color scheme for theming
	 
]]
--[[
	*
	 * Size variants for components
	 
]]
--[[
	*
	 * Color variants for components
	 
]]
--[[
	*
	 * Border radius presets
	 
]]
return nil
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="37">
          <Properties>
            <string name="Name">common</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * Base props that all components should extend from
	 
]]
--[[
	*
	 * Props for components that can be interacted with
	 
]]
--[[
	*
	 * Common color scheme for theming
	 
]]
--[[
	*
	 * Size variants for components
	 
]]
--[[
	*
	 * Color variants for components
	 
]]
--[[
	*
	 * Border radius presets
	 
]]
return nil
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="38">
          <Properties>
            <string name="Name">image-assets</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--/ <reference types="@rbxts/types" />
--[[
	*
	 * @file        src/shared/asset-ids/image-assets.ts
	 * @summary     Image asset constants for the game.
	 * @module      ImageAssets
	 * @layer       shared/asset-ids
	 * @description List of image asset IDs used in the game.
	 * @author       Trembus
	 * @license      MIT
	 * @since        0.1.0
	 * @lastUpdated  2025-06-10 by Trembus
	/* =============================================== Image Constants =============================================== 
]]
local MenuButtonImageMap = {
	Settings = "rbxassetid://122289639886993",
	Inventory = "rbxassetid://132702292243603",
	Character = "rbxassetid://100274464430589",
	Quests = "rbxassetid://129030346503415",
	Shop = "rbxassetid://101998590177560",
	Teleport = "rbxassetid://127118741571164",
	GemForge = "rbxassetid://116506062642047",
	Developer = "rbxassetid://95069877371395",
}
local ImageConstants = {
	IconButtonBackground = "rbxassetid://79163709624038",
	DefaultUnassigned = "rbxassetid://117838504772569",
	Ability = {
		Background = "rbxassetid://91419725020401",
		Unassigned = "rbxassetid://98384046526938",
		Flame_Sythe = "rbxassetid://108246514585300",
		HallowHold = "rbxassetid://79001631229851",
		Fireball = "rbxassetid://108246514585301",
		Ice_Rain = "rbxassetid://77085115837905",
		Lightning_Bolt = "rbxassetid://84562572112570",
		Earthquake = "rbxassetid://72703784685790",
		Melee = "rbxassetid://114327486101696",
		Blood_Siphon = "rbxassetid://135950973087916",
		Blood_Horror = "rbxassetid://82257212198629",
		Blood_Elemental = "rbxassetid://122556254156811",
		Soul_Drain = "rbxassetid://78703065651895",
	},
	Attributes = {
		Strength = "rbxassetid://127745571044516",
		Agility = "rbxassetid://73893872719367",
		Intellect = "rbxassetid://107600003376684",
		Vitality = "rbxassetid://121291227474039",
		Luck = "rbxassetid://114767496083209",
	},
	Beam = {
		Constrictor_1 = "rbxassetid://75175588188120",
		Constrictor_2 = "rbxassetid://117812481070645",
		SoulDrain_1 = "rbxassetid://95584643329398",
		SoulDrain_2 = "rbxassetid://98023166137532",
		IceChain_1 = "rbxassetid://101823462513180",
		IceChain_2 = "rbxassetid://136513380446132",
	},
	Borders = {
		GothicMetal = "rbxassetid://80375133768026",
		RedThick = "rbxassetid://134322739825066",
		CommonSet = "rbxassetid://85778039199330",
		RareSet = "rbxassetid://82228066842612",
		EpicSet = "rbxassetid://135166624307221",
		LegendarySet = "rbxassetid://85570068018789",
	},
	Control = {
		Increment = "rbxassetid://102421835119714",
		Decrement = "rbxassetid://78091115085992",
		Close = "rbxassetid://91437543746962",
		TripleArrow = "rbxassetid://136693752293641",
		Play = "rbxassetid://138751166365431",
	},
	Currency = {
		Coins = "rbxassetid://127745571044516",
		Shards = "rbxassetid://73893872719367",
		Tombs = "rbxassetid://121291227474039",
	},
	Gems = {
		Colorable = "rbxassetid://71842732472075",
		Common = "rbxassetid://71842732472075",
		Uncommon = "rbxassetid://71842732472075",
		Rare = "rbxassetid://71842732472075",
		Epic = "rbxassetid://119000054151103",
		Legendary = "rbxassetid://71842732472075",
	},
	SlotImage = {
		Unassigned = "rbxassetid://98384046526938",
		Helmet = "rbxassetid://98384046526938",
		Armor = "rbxassetid://98384046526938",
		Weapon = "rbxassetid://98384046526938",
		Accessory = "rbxassetid://98384046526938",
	},
	StatusIcon = {
		DarkEnergy = "rbxassetid://112790635225543",
		LightEnergy = "rbxassetid://128191185980101",
		Might = "rbxassetid://121141253261646",
		Chill = "rbxassetid://106953131478004",
		FlightChill = "rbxassetid://95573543624955",
		Shattered = "rbxassetid://135235376575135",
	},
	TextureImage = {
		BoneDoily = "rbxassetid://108018297611555",
		Mystical = "rbxassetid://108018297611556",
		WavyMetal = "rbxassetid://99123505462124",
	},
	Screens = {
		Loading = "rbxassetid://70565375536693",
		GameTitle = "rbxassetid://83079804672155",
	},
}
return {
	MenuButtonImageMap = MenuButtonImageMap,
	ImageConstants = ImageConstants,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="39">
          <Properties>
            <string name="Name">tabs</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--* Describes an individual tab in a TabGroup 
--* Props to configure a TabGroup organism 
return nil
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="40">
          <Properties>
            <string name="Name">ui-constants</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local UI_SIZES = {
	BUTTON_COOLDOWN = UDim2.new(0, 70, 0, 90),
	BUTTON_ICON = UDim2.new(0, 50, 0, 50),
	PROGRESS_BAR = UDim2.new(0, 70, 0, 20),
}
local UI_FLEX_SIZES = {
	FLEX_SHRINK = function()
		local flexItem = Instance.new("UIFlexItem")
		flexItem.FlexMode = Enum.UIFlexMode.Shrink
		return flexItem
	end,
	FLEX_GROW = function()
		local flexItem = Instance.new("UIFlexItem")
		flexItem.FlexMode = Enum.UIFlexMode.Grow
		return flexItem
	end,
}
local LAYOUTS = {
	Vertical = function(spacing)
		if spacing == nil then
			spacing = 0
		end
		local layout = Instance.new("UIListLayout")
		layout.FillDirection = Enum.FillDirection.Vertical
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.Padding = UDim.new(0, spacing)
		return layout
	end,
	Horizontal = function(spacing)
		if spacing == nil then
			spacing = 0
		end
		local layout = Instance.new("UIListLayout")
		layout.FillDirection = Enum.FillDirection.Horizontal
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.Padding = UDim.new(0, spacing)
		return layout
	end,
	Grid = function(cellSize, spacing)
		if spacing == nil then
			spacing = 0
		end
		local layout = Instance.new("UIGridLayout")
		layout.CellSize = cellSize
		layout.SortOrder = Enum.SortOrder.LayoutOrder
		layout.CellPadding = UDim2.fromOffset(0, spacing)
		return layout
	end,
}
return {
	UI_SIZES = UI_SIZES,
	UI_FLEX_SIZES = UI_FLEX_SIZES,
	LAYOUTS = LAYOUTS,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="41">
        <Properties>
          <string name="Name">utils</string>
        </Properties>
        <Item class="ModuleScript" referent="42">
          <Properties>
            <string name="Name">theme</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
--[[
	*
	 * Default color scheme for the component library
	 
]]
local defaultColorScheme = {
	Primary = Color3.fromRGB(59, 130, 246),
	Secondary = Color3.fromRGB(107, 114, 128),
	Accent = Color3.fromRGB(168, 85, 247),
	Background = Color3.fromRGB(255, 255, 255),
	Surface = Color3.fromRGB(249, 250, 251),
	OnPrimary = Color3.fromRGB(255, 255, 255),
	OnSecondary = Color3.fromRGB(255, 255, 255),
	OnBackground = Color3.fromRGB(17, 24, 39),
	OnSurface = Color3.fromRGB(55, 65, 81),
	Error = Color3.fromRGB(239, 68, 68),
	Success = Color3.fromRGB(34, 197, 94),
	Warning = Color3.fromRGB(245, 158, 11),
}
--[[
	*
	 * Border radius values in pixels
	 
]]
local borderRadiusValues = {
	none = 0,
	small = 4,
	medium = 8,
	large = 16,
	full = 9999,
}
--[[
	*
	 * Standard spacing values following 4px grid
	 
]]
local spacing = {
	xs = 4,
	sm = 8,
	md = 16,
	lg = 24,
	xl = 32,
	xxl = 48,
	xxxl = 64,
}
--[[
	*
	 * Standard font sizes
	 
]]
local fontSizes = {
	xs = 12,
	sm = 14,
	md = 16,
	lg = 18,
	xl = 20,
	xxl = 24,
	xxxl = 32,
}
--[[
	*
	 * Standard z-index values for layering
	 
]]
local zIndex = {
	background = -1,
	base = 0,
	dropdown = 1000,
	sticky = 1020,
	fixed = 1030,
	modal = 1040,
	popover = 1050,
	tooltip = 1060,
	toast = 1070,
}
return {
	defaultColorScheme = defaultColorScheme,
	borderRadiusValues = borderRadiusValues,
	spacing = spacing,
	fontSizes = fontSizes,
	zIndex = zIndex,
}
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="43">
      <Properties>
        <string name="Name">node_modules</string>
      </Properties>
      <Item class="Folder" referent="44">
        <Properties>
          <string name="Name">@rbxts</string>
        </Properties>
        <Item class="Folder" referent="45">
          <Properties>
            <string name="Name">compiler-types</string>
          </Properties>
          <Item class="ModuleScript" referent="46">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	author = "roblox-ts",
	description = "",
	devDependencies = {
		["@rbxts/types"] = "^1.0.805",
		["@typescript-eslint/eslint-plugin"] = "^8.5.0",
		["@typescript-eslint/parser"] = "^8.5.0",
		eslint = "^8.57.0",
		["eslint-config-prettier"] = "^9.1.0",
		["eslint-plugin-no-autofix"] = "^2.1.0",
		["eslint-plugin-prettier"] = "^5.2.1",
		["eslint-plugin-simple-import-sort"] = "^12.1.1",
		prettier = "^3.3.3",
		typescript = "^5.2.2",
	},
	files = {"types/*.d.ts"},
	license = "MIT",
	main = "types/core.d.ts",
	name = "@rbxts/compiler-types",
	scripts = {
		eslint = "npx eslint \"types/**/*.d.ts\" --max-warnings 0",
	},
	types = "types/core.d.ts",
	version = "3.0.0-types.0",
}</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="47">
            <Properties>
              <string name="Name">types</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="48">
          <Properties>
            <string name="Name">fusion</string>
          </Properties>
          <Item class="ModuleScript" referent="49">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	author = "Elttob",
	bugs = "https://github.com/Dionysusnu/Fusion/issues",
	contributors = {{
		name = "Dionysusnu",
		url = "https://github.com/Dionysusnu",
	}},
	description = "TypeScript support for Fusion",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.2.3-types.0",
		["@rbxts/types"] = "^1.0.519",
		["@typescript-eslint/eslint-plugin"] = "^4.29.2",
		["@typescript-eslint/parser"] = "^4.29.2",
		eslint = "^7.32.0",
		["eslint-config-prettier"] = "^6.15.0",
		["eslint-plugin-prettier"] = "^3.4.0",
		["eslint-plugin-roblox-ts"] = "^0.0.8",
		["eslint-plugin-simple-import-sort"] = "^7.0.0",
		prettier = "^2.3.1",
		typescript = "^4.3.4",
	},
	directories = {
		lib = "src",
	},
	files = {"src"},
	keywords = {"roblox", "typescript", "fusion"},
	license = "MIT",
	main = "src/init.lua",
	name = "@rbxts/fusion",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Dionysusnu/Fusion.git",
	},
	scripts = {
		["dev-add-version"] = "copy package.json package-temp.json &amp; for /F \"tokens=*\" %n IN ('git rev-parse --short HEAD') DO (cat package.json | jq --tab \".version |= . + \\\"-dev-%n\\\"\" > package-new.json &amp; move package-new.json package.json)",
		["dev-publish"] = "npm test &amp;&amp; npm run eslint &amp;&amp; npm run dev-add-version &amp;&amp; npm publish --tag next &amp; npm run dev-undo-version",
		["dev-publish-no-test"] = "npm run eslint &amp;&amp; npm run dev-add-version &amp;&amp; npm publish --tag next &amp; npm run dev-undo-version",
		["dev-undo-version"] = "move package-temp.json package.json",
		eslint = "eslint \"src/**/*.ts\" --max-warnings 0",
		["eslint-fix"] = "eslint \"src/**/*.ts\" --fix",
		test = "npm run test-build &amp;&amp; npm run test-run",
		["test-build"] = "rojo build test-runner.project.json -o test.rbxl",
		["test-run"] = "run-in-roblox --place test.rbxl --script test-runner/Run.client.lua",
	},
	typings = "src/index.d.ts",
	version = "0.2.0",
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="50">
            <Properties>
              <string name="Name">src</string>
              <string name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion
]]></string>
            </Properties>
            <Item class="Folder" referent="51">
              <Properties>
                <string name="Name">Animation</string>
              </Properties>
              <Item class="ModuleScript" referent="52">
                <Properties>
                  <string name="Name">Spring</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping &lt; 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed &lt; 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring&lt;T>(
	goalState: PubTypes.Value&lt;T>,
	speed: PubTypes.CanBeState&lt;number>?,
	damping: PubTypes.CanBeState&lt;number>?
): Types.Spring&lt;T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="53">
                <Properties>
                  <string name="Name">SpringScheduler</string>
                  <string name="Source">--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set&lt;T> = {[T]: any}
type Spring = Types.Spring&lt;any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set&lt;Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set&lt;Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="54">
                <Properties>
                  <string name="Name">Tween</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween&lt;T>(
	goalState: PubTypes.StateObject&lt;PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState&lt;TweenInfo>?
): Types.Tween&lt;T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="55">
                <Properties>
                  <string name="Name">TweenScheduler</string>
                  <string name="Source">--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set&lt;T> = {[T]: any}
type Tween = Types.Tween&lt;any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set&lt;Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="56">
                <Properties>
                  <string name="Name">getTweenRatio</string>
                  <string name="Source">--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime &lt;= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="57">
                <Properties>
                  <string name="Name">lerpType</string>
                  <string name="Source">--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio &lt; 0.5 then
		return from
	else
		return to
	end
end

return lerpType</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="58">
                <Properties>
                  <string name="Name">packType</string>
                  <string name="Source">--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="59">
                <Properties>
                  <string name="Name">springCoefficients</string>
                  <string name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -ζω ± Sqrt[ζ^2 - 1] ω
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-tω)(1+tω) + v0(e^-tω)t
		-- v[t] -> x0(t ω^2)(-e^-tω) + v0(1 - tω)(e^-tω)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		-- α = Sqrt[1 - ζ^2]
		-- x[t] -> x0(e^-tζω)(α Cos[tα] + ζω Sin[tα])/α
		--       + v0(e^-tζω)(Sin[tα])/α
		-- v[t] -> x0(-e^-tζω)(α^2 + ζ^2 ω^2)(Sin[tα])/α
		--       + v0(e^-tζω)(α Cos[tα] - ζω Sin[tα])/α

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="60">
                <Properties>
                  <string name="Name">unpackType</string>
                  <string name="Source">--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="61">
              <Properties>
                <string name="Name">Colour</string>
              </Properties>
              <Item class="ModuleScript" referent="62">
                <Properties>
                  <string name="Name">Oklab</string>
                  <string name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="63">
              <Properties>
                <string name="Name">Dependencies</string>
              </Properties>
              <Item class="ModuleScript" referent="64">
                <Properties>
                  <string name="Name">captureDependencies</string>
                  <string name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="65">
                <Properties>
                  <string name="Name">initDependency</string>
                  <string name="Source">--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="66">
                <Properties>
                  <string name="Name">sharedState</string>
                  <string name="Source">--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set&lt;PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set&lt;PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="67">
                <Properties>
                  <string name="Name">updateAll</string>
                  <string name="Source">--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}
type Descendant = (PubTypes.Dependent &amp; PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos &lt;= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos &lt;= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="68">
                <Properties>
                  <string name="Name">useDependency</string>
                  <string name="Source">--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="69">
              <Properties>
                <string name="Name">Instances</string>
              </Properties>
              <Item class="ModuleScript" referent="70">
                <Properties>
                  <string name="Name">Children</string>
                  <string name="Source">--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set&lt;T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set&lt;Instance> = {}
	local oldParented: Set&lt;Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject&lt;any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="71">
                <Properties>
                  <string name="Name">Cleanup</string>
                  <string name="Source">--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="72">
                <Properties>
                  <string name="Name">Hydrate</string>
                  <string name="Source">--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="73">
                <Properties>
                  <string name="Name">New</string>
                  <string name="Source">--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="74">
                <Properties>
                  <string name="Name">OnChange</string>
                  <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="75">
                <Properties>
                  <string name="Name">OnEvent</string>
                  <string name="Source">--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="76">
                <Properties>
                  <string name="Name">Out</string>
                  <string name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="77">
                <Properties>
                  <string name="Name">Ref</string>
                  <string name="Source">--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="78">
                <Properties>
                  <string name="Name">applyInstanceProps</string>
                  <string name="Source">--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState&lt;any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="79">
                <Properties>
                  <string name="Name">defaultProps</string>
                  <string name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="80">
              <Properties>
                <string name="Name">Logging</string>
              </Properties>
              <Item class="ModuleScript" referent="81">
                <Properties>
                  <string name="Name">logError</string>
                  <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="82">
                <Properties>
                  <string name="Name">logErrorNonFatal</string>
                  <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="83">
                <Properties>
                  <string name="Name">logWarn</string>
                  <string name="Source">--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="84">
                <Properties>
                  <string name="Name">messages</string>
                  <string name="Source">--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="85">
                <Properties>
                  <string name="Name">parseError</string>
                  <string name="Source">--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="86">
              <Properties>
                <string name="Name">PubTypes</string>
                <string name="Source">--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set&lt;Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set&lt;Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject&lt;T> = Dependency &amp; {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject&lt;T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState&lt;T> = StateObject&lt;T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value&lt;T> = StateObject&lt;T> &amp; {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value&lt;T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KO, VO> = StateObject&lt;{ [KO]: VO }> &amp; Dependent &amp; {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KO, V> = StateObject&lt;{ [KO]: V }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;K, VO> = StateObject&lt;{ [K]: VO }> &amp; Dependent &amp; {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = StateObject&lt;T> &amp; Dependent &amp; {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring&lt;T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring&lt;T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring&lt;T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent &amp; {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject&lt;Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="87">
              <Properties>
                <string name="Name">State</string>
              </Properties>
              <Item class="ModuleScript" referent="88">
                <Properties>
                  <string name="Name">Computed</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed&lt;T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="89">
                <Properties>
                  <string name="Name">ForKeys</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys&lt;KI, KO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys&lt;KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="90">
                <Properties>
                  <string name="Name">ForPairs</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs&lt;KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs&lt;KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="91">
                <Properties>
                  <string name="Name">ForValues</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues &lt;= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues&lt;VI, VO, M>(
	inputTable: PubTypes.CanBeState&lt;{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues&lt;VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="92">
                <Properties>
                  <string name="Name">Observer</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set&lt;T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set&lt;Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value&lt;any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="93">
                <Properties>
                  <string name="Name">Value</string>
                  <string name="Source">--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value&lt;T>(initialValue: T): Types.State&lt;T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="94">
                <Properties>
                  <string name="Name">unwrap</string>
                  <string name="Source">--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap&lt;T>(item: PubTypes.CanBeState&lt;T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject&lt;T>):get(useDependency) else (item :: T)
end

return unwrap</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="95">
              <Properties>
                <string name="Name">Types</string>
                <string name="Source">--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set&lt;T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol &amp; {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State&lt;T> = PubTypes.Value&lt;T> &amp; {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed&lt;T> = PubTypes.Computed&lt;T> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs&lt;KI, VI, KO, VO, M> = PubTypes.ForPairs&lt;KO, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys&lt;KI, KO, M> = PubTypes.ForKeys&lt;KO, any> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues&lt;VI, VO, M> = PubTypes.ForValues&lt;any, VO> &amp; {
	_oldDependencySet: Set&lt;PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState&lt;{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set&lt;PubTypes.Dependency>,
			oldDependencySet: Set&lt;PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween&lt;T> = PubTypes.Tween&lt;T> &amp; {
	_goalState: State&lt;T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring&lt;T> = PubTypes.Spring&lt;T> &amp; {
	_speed: PubTypes.CanBeState&lt;number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState&lt;number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State&lt;T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer &amp; {
	_changeListeners: Set&lt;() -> ()>,
	_numChangeListeners: number
}

return nil</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="96">
              <Properties>
                <string name="Name">Utility</string>
              </Properties>
              <Item class="ModuleScript" referent="97">
                <Properties>
                  <string name="Name">None</string>
                  <string name="Source">--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="98">
                <Properties>
                  <string name="Name">cleanup</string>
                  <string name="Source">--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="99">
                <Properties>
                  <string name="Name">doNothing</string>
                  <string name="Source">--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="100">
                <Properties>
                  <string name="Name">isSimilar</string>
                  <string name="Source">--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="101">
                <Properties>
                  <string name="Name">needsDestruction</string>
                  <string name="Source">--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="102">
                <Properties>
                  <string name="Name">restrictRead</string>
                  <string name="Source">--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="103">
                <Properties>
                  <string name="Name">xtypeof</string>
                  <string name="Source">--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="104">
          <Properties>
            <string name="Name">testez</string>
          </Properties>
          <Item class="ModuleScript" referent="105">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	author = "Roblox",
	bugs = {
		url = "https://github.com/roblox-ts/testez/issues",
	},
	description = "A fork of TestEZ with TypeScript typings",
	devDependencies = {
		["@rbxts/types"] = "^1.0.350",
		["@typescript-eslint/eslint-plugin"] = "^2.17.0",
		["@typescript-eslint/parser"] = "^2.17.0",
		eslint = "^6.8.0",
		["eslint-config-prettier"] = "^6.9.0",
		["eslint-plugin-prettier"] = "^3.1.2",
		["eslint-plugin-roblox-ts"] = "0.0.7",
		prettier = "^1.19.1",
	},
	files = {"src", "globals.d.ts"},
	homepage = "https://github.com/roblox-ts/testez#readme",
	keywords = {},
	license = "Apache 2.0",
	main = "src/init.lua",
	name = "@rbxts/testez",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/testez",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "0.4.2-ts.0",
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="106">
            <Properties>
              <string name="Name">src</string>
              <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
            </Properties>
            <Item class="ModuleScript" referent="107">
              <Properties>
                <string name="Name">Context</string>
                <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="108">
              <Properties>
                <string name="Name">Expectation</string>
                <string name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end

function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()
			return self
		end)
	end

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (typeof(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

-- Make alias public on class
Expectation.an = Expectation.a

--[[
	Assert that our expectation value is not nil
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called.
	An optional error message can be passed to assert that the error message
	contains the given value.
]]
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(self.successCondition,
			("Expected function to throw an error containing %q, but it %s"):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			("Expected function to never throw an error containing %q, but it threw: %s"):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(
				tostring(err)
			)
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="109">
              <Properties>
                <string name="Name">ExpectationContext</string>
                <string name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}
ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end

function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end

function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="110">
              <Properties>
                <string name="Name">LifecycleHooks</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="111">
              <Properties>
                <string name="Name">Reporters</string>
              </Properties>
              <Item class="ModuleScript" referent="112">
                <Properties>
                  <string name="Name">TeamCityReporter</string>
                  <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="113">
                <Properties>
                  <string name="Name">TextReporter</string>
                  <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="114">
                <Properties>
                  <string name="Name">TextReporterQuiet</string>
                  <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="115">
              <Properties>
                <string name="Name">TestBootstrap</string>
                <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="116">
              <Properties>
                <string name="Name">TestEnum</string>
                <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="117">
              <Properties>
                <string name="Name">TestPlan</string>
                <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = setmetatable({
		extend = function(...)
			error("Cannot call \"expect.extend\" from within a \"describe\" node.")
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	-- Copy 'script' directly to new env to make Studio debugger happy.
	-- Studio debugger does not look into __index, because of security reasons
	callbackEnv.script = originalEnv.script
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="118">
              <Properties>
                <string name="Name">TestPlanner</string>
                <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="119">
              <Properties>
                <string name="Name">TestResults</string>
                <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="120">
              <Properties>
                <string name="Name">TestRunner</string>
                <string name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end

		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. debug.traceback(tostring(message), 2)
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				if not testSuccess then
					return false, testErrorMessage .. "\nWhile cleaning up the failed test another error was found:\n" .. errorMessage
				end
				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="121">
              <Properties>
                <string name="Name">TestSession</string>
                <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)
	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)
	table.insert(self.expectationContextStack, expectationContext)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end


function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")
	return self.expectationContextStack[#self.expectationContextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="122">
          <Properties>
            <string name="Name">types</string>
          </Properties>
          <Item class="Folder" referent="123">
            <Properties>
              <string name="Name">include</string>
            </Properties>
            <Item class="Folder" referent="124">
              <Properties>
                <string name="Name">generated</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="125">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	author = "roblox-ts",
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	dependencies = {
	},
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.868",
}</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="126">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="127">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="128">
        <Properties>
          <string name="Name">Tests</string>
        </Properties>
        <Item class="Folder" referent="129">
          <Properties>
            <string name="Name">helpers</string>
          </Properties>
          <Item class="LocalScript" referent="130">
            <Properties>
              <string name="Name">bootstrap</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--/ <reference types="@rbxts/testez/globals" />
local TestEZ = TS.import(script, TS.getModule(script, "@rbxts", "testez").src)
local results = TestEZ.TestBootstrap:run({ script })
print(`[ss-fusion] Test run: success={results.successCount} failure={results.failureCount} skipped={results.skippedCount}`)
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="131">
          <Properties>
            <string name="Name">unit</string>
          </Properties>
          <Item class="Folder" referent="132">
            <Properties>
              <string name="Name">atoms</string>
            </Properties>
            <Item class="ModuleScript" referent="133">
              <Properties>
                <string name="Name">Button.spec</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = _G[script]
--/ <reference types="@rbxts/testez/globals" />
local Button = TS.import(script, script.Parent.Parent.Parent.Parent.Parent.Parent, "ReplicatedStorage", "TS", "atoms", "Button").Button
return function()
	describe("Button", function()
		it("creates a Frame with InteractionButton", function()
			local frame = Button({
				text = "Click me",
			})
			expect(frame:IsA("Frame")).to.equal(true)
			expect(frame:FindFirstChild("InteractionButton")).to.be.ok()
			frame:Destroy()
		end)
	end)
end
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>